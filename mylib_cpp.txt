abc251e{
  #include <iostream>
  using namespace std;
  typedef long long ll;
  const ll inf = 1e18;

  int n;
  int a[300005];
  ll dp[300005][2];

  int main(void)
  {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    
    ll ans = inf;
    for(int t = 0; t <= 1; t++){
      dp[1][t] = a[1]*t, dp[1][1-t] = inf;
      
      for(int i = 2; i <= n; i++){
        dp[i][0] = dp[i-1][1];
        dp[i][1] = min(dp[i-1][0], dp[i-1][1]) + a[i];
      }
      if(t == 0) ans = min(ans, dp[n][1]);
      if(t == 1) ans = min(ans, min(dp[n][0], dp[n][1]));
    }
    cout << ans << endl;
    
    return 0;
  } 

}

abc251g{
  #include <iostream>
  using namespace std;
  typedef long long ll;
  const ll inf = 1e18;

  ll n, m, q;
  ll x[55], y[55];
  ll u[200005], v[200005];
  ll Q1[55], Q2[55], R[55];

  ll cross(ll p, ll q, ll r, ll s){
    return p*s - q*r;
  }

  int main(void)
  {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> x[i] >> y[i];
    x[n+1] = x[1], y[n+1] = y[1];
    cin >> m;
    for(int i = 1; i <= m; i++) cin >> u[i] >> v[i];
    
    for(int i = 1; i <= n; i++){
      Q1[i] = x[i+1]-x[i], Q2[i] = y[i+1]-y[i], R[i] = -inf;
      for(int j = 1; j <= m; j++){
        R[i] = max(R[i], cross(x[i+1]-x[i], y[i+1]-y[i], x[i]+u[j], y[i]+v[j]));
      }
    }
    
    cin >> q;
    ll a, b;
    for(int k = 1; k <= q; k++){
      cin >> a >> b;
      bool ans = true;
      for(int i = 1; i <= n; i++) if(cross(Q1[i], Q2[i], a, b) < R[i]) ans = false;
      if(ans) cout << "Yes" << "\n";
      else cout << "No" << "\n";
    }
    
    return 0;
  } 

}

abc251f{
  #include <iostream>
  #include <utility>
  #include <queue>
  using namespace std;
  typedef long long ll;
  typedef pair<int, int> P;
  const ll inf = 1e18;

  int n, m;
  vector<int> G[200005];
  bool visited[200005];
  vector<P> T1, T2;

  void dfs(int v)
  {
    visited[v] = true;
    for(auto u : G[v]){
      if(!visited[u]){
        T1.push_back(P(v, u));
        dfs(u);
      }
    }
  }
  void bfs()
  {
    for(int i = 1; i <= n; i++) visited[i] = false;
    queue<int> Q;
    Q.push(1), visited[1] = true;
    
    int v;
    while(Q.size()){
      v = Q.front(), Q.pop();
      for(auto u : G[v]){
        if(!visited[u]){
          T2.push_back(P(v, u));
          visited[u] = true;
          Q.push(u);
        }
      }
    }
  }

  int main(void)
  {
    cin >> n >> m;
    int u, v;
    for(int i = 1; i <= m; i++){
      cin >> u >> v;
      G[u].push_back(v);
      G[v].push_back(u);
    }
    
    dfs(1);
    bfs();
    
    for(auto p : T1) cout << p.first << " " << p.second << "\n";
    for(auto p : T2) cout << p.first << " " << p.second << "\n";
    
    return 0;
  } 

}

void 251B_At_Most_3(){
  int N,W; cin >> N >> W;
  vi A(N+2);
  rep(i,N) cin >> A[i];
  A[N]=A[N+1]=0;
  set<int> st;
  rep(i,N){
    rep2(j,i+1,N+1){
      rep2(k,j+1,N+2){
        int sum = 0;
        sum= A[i]+A[j]+A[k];
        if(sum<=W){
          st.insert(sum);
        }
      }
    }
  }
  int ans = st.size();
  cout << ans << endl;
  return;
} 

void 251D_At_Most_3(){
    int W; cin >> W;
    vi a;
    REP2(i,1,99){
        a.push_back(i);
        a.push_back(i*100);
        a.push_back(i*10000);
    }
    cout << a.size() << endl;
    vector_output(a);
    return;
}

void 251TwoSpanningTree(){

  int N,M;
  cin >> N >> M;
  vi G(200005);
  vb visited(200005);
  vpi T1,T2;

  void dfs(int v){
    visited[v] = true;
    for(auto u: G[v]){
      if(!visited[u]){
        T1.push_back(P(v,u));
        dfs(u);
      }
    }
  }

  void bfs(){
    REP2(i,1,N) visited[i] = false;
    que<int> Q;
    Q.push(1), visited[1] = true;

    int v;
    while(Q.size()){
      v = Q.front(), Q.pop();
      for(auto u: G[v]){
        if(!visited[u]){
          T2.push_back(P(v,u));
          visited[u] = true;
          Q.push(u);
        }
      }
    }
  }

  int u,v;
  REP2(i,1,M){
    cin >> u >> v;
    G[u].push_back(v);
    G[v].push_back(u);
  }
  dfs(1);
  bfs();

  for(auto p: T1) cout << p.first << " " << p.second << endl;
  for(auto p: T2) cout << p.first << " " << p.second << endl;
}

void 249A_Jogging(){
    int A,B,C,D,E,F,X;
    cin >> A >> B >>C >> D >> E >> F >> X;

    int takahashi = 0;
    int aoki = 0;

    rep(i,X){
        int time1 = i%(A+C);
        if(time1<A) takahashi+=B;
        
        int time2 = i%(D+F);
        if(time2<D) aoki+=E;
    }
    if(aoki<takahashi) cout << "Takahashi" << endl;
    else if(aoki == takahashi) cout << "Draw" << endl;
    else cout << "Aoki" << endl;
}

void algo_linked_list(){
    struct Node {
        Node* nex;  // 次がどのノードを指すか
        Node* pre;
        string value;  // ノードに付随している値
        Node(const string& value = "") : nex(NULL), value(value) { }
    };

    // 番兵を表すノード (ここではグローバルに置いておく)
    Node* nil;

    // 連結リストの初期化
    void init() {
        nil = new Node();
        nil->nex = nil; // 初期状態では nil が nil を指すように
        nil->pre = nil;
    }

    // 連結リストへ先頭への要素の挿入
    void insert(Node* v) {
        v->nex = nil->nex;  // v の次を、現在の先頭に
        nil->nex = v;  // 先頭を v に書き換える
    }

    void PushHead(Node* v){
    v->nex = nil->nex;
    v->pre = nil;
    nil->nex = v;
    (v->nex)->pre = v;
    return;
    }

    string PopTail(){
    Node *tail = nil->pre;
    if(tail == nil){
        return "Error";
    }else{
        string ret = tail->value;
        nil->pre = tail->pre;
        (nil->pre)->nex = nil;
        delete tail;

        return ret;
    }
    }

    string erase(){
    Node *front = nil->nex;
    if(front == nil){
        return "Error";
    }else{
        string ret = front->value;
        nil->nex = front->nex;
        delete front;
        return ret;
    }
    }
}

void abc250e(){
    int n;  cin >> n;
  vi a(n),b(n);
  rep(i,n) cin >> a[i];
  rep(i,n) cin >> b[i];
  map<int,int> mp;
  vi ca(n),cb(n),mx(n);

  rep(i,n){
    if(!mp.count(a[i])) mp[a[i]] = mp.size()+1;
    ca[i] = mp.size();
  }  
  
  const int INF = 100100100;
  set<int> st;
  int m=0;
  rep(i,n){
    st.insert(b[i]);
    int x = mp[b[i]];
    if(x==0) x = INF;
    m = max(m,x);
    mx[i] = m;
    cb[i] = st.size();
  }
  int q; cin >> q;
  while(q--){
    int x,y; cin >> x >> y;
    x--,y--;
    if(ca[x]==cb[y] && cb[y]==mx[y]){
      cout << "Yes" << endl;
    }else{
      cout << "No" << endl;
    }
  }
}

void abc249e{
    ll n,p; cin >> n >> p;
    vvl dp(3101,vl(3101));
    vvl sum(3101,vl(3101));
    dp[0][0] = modPow(25,p-2,p)*26ll%p;
    vl ten;
    rep(i,6) ten.push_back(pow(10,i));
    REP2(i,1,n) sum[0][i] = dp[0][0];
    REP2(i,1,n){
        REP2(j,1,n){
        REP2(k,1,4){
            if(i-k-1<0) continue;
            ll x = max(j-ten[k-1]+1,0ll),y = max(j-ten[k]+1,0ll);
            dp[i][j] += (sum[i-k-1][x] -sum[i-k-1][y]+p)*25;
            dp[i][j]%=p;
        }
        sum[i][j+1] = sum[i][j] +dp[i][j];
        sum[i][j+1] %= p;
        }
    }
    ll s = 0;
    rep2(i,1,n) s+=dp[i][n];
    cout << s%p << endl;
    return;
}

void abc249f(){
    int n,k; cin >> n >> k;
  vi t(n+1),y(n+1);

  t[0]=1,y[0]=0;
  REP2(i,1,n){
    cin >> t[i] >> y[i];
  }

  ll ans = numeric_limits<ll>::min(), sum=0;

  max_heap<int> ignore;
  min_heap<int> take;

  for(int i=n;i>=0;--i){
    if(t[i]==1){
      ans = max(ans,y[i]+sum);
      k-=1;
    }else{
      if(y[i] >= 0){
        sum += y[i];
        take.push(y[i]);
      }else{
        ignore.push(y[i]);
      }
    }
    if((int)ignore.size() > k){
      if(ignore.empty()){
        break;
      }
      const int val = ignore.top();
      ignore.pop();
      sum += val;
      take.push(val);
    }
  }
  cout << ans << endl;
  return;
}

void abc247e(){
  ll N,X,Y;
  cin >> N >> X >> Y;  
  vector<int> A(N);

  rep(i,N) cin >> A[i];

  int posX{-1}, posY{-1}, B{-1};

  ll res{};
  rep(i,N){
    if(A[i]==X) posX=i;
    if(A[i]==Y) posY=i;
    if(A[i]<Y or X<A[i]) B=i;
    res += max(0,min(posX,posY)-B);
  }
  cout << res << endl;
} 

void abc246e(){

int N;
int Ax,Ay,Bx,By;
string S[1510];

int dx2[4]={1,1,-1,-1};
int dy2[4]={1,-1,1,-1};

int opt[1510][1510][5];
bool vis[1510][1510][5];

int main() {
    

    cin >> N;

    cin >> Ay >> Ax >> By >> Bx;

    Ax--,Ay--,Bx--,By--;
    rep(y,N) cin >> S[y];

    min_heap<pair<int, tuple<int,int,int>>> que;
    rep(x,N) rep(y,N) rep(dir,5) opt[y][x][dir] = INT_MAX;
    rep(x,N) rep(y,N) rep(dir,5) vis[y][x][dir] = false;

    opt[Ay][Ax][4]=0;
    que.push({0,{Ax,Ay,4}});

    while(!que.empty()){
        int x,y,dir;
        tie(x,y,dir) = que.top().second;
        que.pop();


        if(vis[y][x][dir]) continue;
        vis[y][x][dir]=true;

        if(x == Bx && y == By){
        cout << opt[y][x][dir] << endl;
        return 0;
        }
        rep(d,4){
        int xx = x+dx2[d];
        int yy = y+dy2[d];

        if(0 <=xx && xx < N && 0<= yy && yy < N){
            if(S[yy][xx] == '#') continue;
            if(chmin(opt[yy][xx][d],opt[y][x][dir]+(dir!=d))){
            que.push({opt[yy][xx][d],{xx,yy,d}});
            }
        }
        }
    }
    cout << -1 << endl;
    }
}

void algo_data_structure_linked_list_deque(){

    struct Node {
        Node* nex;  // 次がどのノードを指すか
        Node* pre;  // 前がどのノードを指すか
        string value;  // ノードに付随している値
        Node(const string& value = "") : nex(NULL), value(value) { }
    };

    Node* nil;

    void init() {
        nil = new Node();
        nil->nex = nil; // 初期状態では nil の次が nil を指すように
        nil->pre = nil; // 初期状態では nil の前が nil を指すように
    }

    // 双方向連結リストへ先頭への要素の挿入
    void PushHead(Node* v) {
        v->nex = nil->nex;  // v の次を、元の先頭要素に
        v->pre = nil;   // v の前を nil に
        nil->nex = v;  // nil の次を v に書き換える
        (v->nex)->pre = v;  // 元の先頭要素の前を v にする
        return;
    }

    // 双方向連結リストへ末尾への要素の挿入
    void PushTail(Node* v) {
        v->nex = nil;   // v の次を nil に
        v->pre = nil->pre;  // v の前を、元の末尾ノードに
        nil->pre = v;   // nil の前を v に
        (v->pre)->nex = v;  // 元の末尾ノードの次を v に
        return;
    }

    // 双方向連結リストの先頭にある文字列を返し、その要素を削除する
    string PopHead() {
        Node *head = nil->nex;  // 先頭のノードを取得する
        if(head == nil) {
            // 双方向連結リストが空なら、Error を返す
            return "Error";
        }
        else {
            string ret = head->value;   // 先頭の文字列を返す
            nil->nex = head->nex;   // nil の次を、head の次に
            (nil->nex)->pre = nil;  // 新たな先頭の前を nil に
            delete head;    // メモリを開放する

            return ret;
        }
    }

    // 双方向連結リストの末尾にある文字列を返し、その要素を削除する
    string PopTail() {
        Node *tail = nil->pre;  // 末尾のノードを取得する
        if(tail == nil) {
            // 双方向連結リストが空なら、Error を返す
            return "Error";
        }
        else {
            string ret = tail->value;   // 末尾の文字列を返す
            nil->pre = tail->pre;   // nil の前を、tail の前に
            (nil->pre)->nex = nil;  // 新たな末尾の次を nil に
            delete tail;    // メモリを開放する

            return ret;
        }
    }

    int main() {
        // 連結リストの初期化
        init(); 

        int Q;
        cin >> Q;
        for (int i = 0; i < Q; ++i) {
            int type; cin >> type;

            if(type == 0) {
                string S; cin >> S;
                Node *v = new Node(S);  // ノードを作成する
                PushHead(v);
            }
            else if(type == 1) {
                string S; cin >> S;
                Node *v = new Node(S);  // ノードを作成する
                PushTail(v);
            }
            else if(type == 2) {
                cout << PopHead() << endl;
            }
            else if(type == 3) {
                cout << PopTail() << endl;
            }
        }
    }
}

void abc180b(){
    double manhatten(vd X){
        double res=0;
        rep(i,X.size()) res+=abs(X[i]);
        return res;
    }

    double uklid(vd X){
        double res=0;
        rep(i,X.size()) res += X[i]*X[i];
        return sqrt(res);
    }

    double chebishef(vd X){
        double res=0;
        rep(i,X.size()) chmax(res,abs(X[i]));
        return res;
    }

    int main(){
        int N; cin >> N;
        vd X(N);
        rep(i,N) cin >> X[i];

        cout << fixed << setprecision(15);
        cout << manhatten(X) << endl;
        cout << uklid(X) << endl;
        cout << chebishef(X) << endl;
    }
}

void abc180c(){
    ll N; cin >> N;

    set<ll> st;
    REP2(i,1,sqrt(N)){
        if(N%i==0){
        st.insert(i);
        st.insert(N/i);
        }
    }
    // sort(st.begin(),st.end());
    for(ll v: st){
        cout << v << endl;
    }
}

void abc180e(){
    int n;
  cin >> n;
  vector<int> x(n), y(n), z(n);
  rep(i,n) cin >> x[i] >> y[i] >> z[i];
  int n2 = 1<<n;
  // dp INF initialize
  vector<vector<int>> dp(n2,vector<int>(n,INF));
  //  dist 0 initialize
  vector<vector<int>> dist(n,vector<int>(n));

  rep(i,n)rep(j,n) {
    // two dimension
    // now = x[i]-x[j]
    // two point select
    //  get dist[i][j]
    int now = abs(x[i]-x[j]);
    now += abs(y[i]-y[j]);
    now += max(0, z[j]-z[i]);
    dist[i][j] = now;
  }
  rep(i,n) {
    if (i == 0) continue;
    // update dist from 0
    dp[1<<i][i] = dist[0][i];
  }
  rep(i,n2)rep(j,n) {
    // i no hitei wo migini shift shita mono ga 1
    // 
    if (~i>>j&1) continue;
    rep(k,n) {
      if (i>>k&1) continue;
      chmin(dp[i|1<<k][k], dp[i][j]+dist[j][k]);
    }
  }
  cout << dp[n2-1][0] << endl;
  return 0;
}

void abc180f(){
    const int MX = 305;
    mint c[MX][MX];
    mint dp[MX][MX];
    
    mint f(int n, int m, int l) {
    vector<mint> path(l+1);
    path[1] = 1;
    path[2] = 1;
    for (int i = 3; i <= l; ++i) path[i] = path[i-1]*i;
    vector<mint> cycle(l+1);
    for (int i = 2; i <= l; ++i) cycle[i] = path[i-1];
    rep(i,n+1)rep(j,m+1) dp[i][j] = 0;
    dp[0][0] = 1;
    rep(i,n+1)rep(j,m+1) {
        for (int k = 1; k <= l; ++k) {
        int ni = i+k;
        int nj = j+k-1;
        if (ni > n) break;
        if (nj > m) break;
        dp[ni][nj] += dp[i][j]*c[n-i-1][k-1]*path[k];
        }
        for (int k = 2; k <= l; ++k) {
        int ni = i+k;
        int nj = j+k;
        if (ni > n) break;
        if (nj > m) break;
        dp[ni][nj] += dp[i][j]*c[n-i-1][k-1]*cycle[k];
        }
    }
    return dp[n][m];
    }
    
    int main() {
    c[0][0] = 1;
    rep(i,MX-1) {
        rep(j,i+1) {
        c[i+1][j] += c[i][j];
        c[i+1][j+1] += c[i][j];
        }
    }
    
    int n, m, l;
    cin >> n >> m >> l;
    mint ans = f(n,m,l) - f(n,m,l-1);
    cout << ans.val() << endl;
    return 0;
    }
}

void abc180c(){
  int n;
  cin >> n;
  ll ans = 0;
  for (int a = 1; a <= n; ++a) {
    ans += (n-1)/a;
  }
  cout << ans << endl;
  return 0;
}

void abc252d(){
  int main() {
  int N;
  cin >> N;
  vector< int > A(N);
  cin >> A;
  map< int, int > mp;
  for(auto &a: A) mp[a]++;
  int64 ret = 0;
  int64 a = 0, b = 0;
  for(auto&[_, p]: mp) {
    ret += b * p;
    b += a * p;
    a += p;
  }
  cout << ret << "\n";
}
}

#include<bits/stdc++.h>
using namespace std;
using ll=long long;

struct edge{
	int to,cost,idx;
};

vector<int> dijkstra(int s,vector<vector<edge>>&G){
	vector<ll>dist(G.size(),1LL<<60);
	vector<int>idx(G.size());
	dist[s]=0;
	using P=pair<ll,int>;
	priority_queue<P,vector<P>,greater<P>> pq;
	pq.push({0,s});

	while(!pq.empty()){
		auto[d,v]=pq.top();
		pq.pop();
		if(dist[v]!=d)continue;
		for(auto[vv,c,i]:G[v]){
			if(dist[vv]>dist[v]+c){
				dist[vv]=dist[v]+c;
				pq.push({dist[vv],vv});
				idx[vv]=i;  //  <- index 
			}
		}
	}
	return idx;
}

int main(){
	int N,M;
	cin >> N >> M;
	vector<vector<edge>>G(N);
	for(int i=0;i<M;i++){
		int a,b,c;
		cin >> a >> b >> c;
		G[a-1].push_back({b-1,c,i});
		G[b-1].push_back({a-1,c,i});
	}
	vector<int> idx=dijkstra(0,G);
	for(int i=1;i<N;i++)cout << idx[i]+1 << ' ';
}

void arc141a(){
  #include <bits/stdc++.h>
using namespace std;
int main(){
  vector<long long> ten(18);
  ten[0] = 1;
  for (int i = 0; i < 17; i++){
    ten[i + 1] = ten[i] * 10;
  }

  int T;
  cin >> T;
  for (int i = 0; i < T; i++){
    long long N;
    cin >> N;
    int L = to_string(N).size();
    long long ans = ten[L - 1] - 1;
    for (int j = 1; j < L; j++){
      if (L % j == 0){
        long long q = 0;
        for (int k = 0; k < L / j; k++){
          q += ten[k * j];
        }
        long long p = N / q * q;
        ans = max(ans, p);
      }
    }
    cout << ans << endl;
  }
}
}



void abc253c{
    #include <bits/stdc++.h>
    using namespace std;

    int main() {
        int q;
        cin >> q;
        multiset<int> st;
        while (q--) {
            int t;
            cin >> t;
            if (t == 1) {
                int x;
                cin >> x;
                st.insert(x);
            } else if (t == 2) {
                int x, c;
                cin >> x >> c;
                while (c-- and st.find(x) != st.end()) {
                    st.erase(st.find(x));
                }
            } else {
                cout << *st.rbegin() - *st.begin() << endl;
            }
        }
    }
}

void abc253d(){
    void solve() {
    LL(N, a, b);
    ll g = gcd(a, b);
    ll lcm = a * b / g;
    
    auto f = [&](ll d) -> ll {
        ll n = N / d;
        return n * (n + 1) / 2 * d;
    };
    
    ll ANS = f(1) - f(a) - f(b) + f(lcm);
    print(ANS);
    }
    
    signed main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cout << setprecision(15);
    
    ll T = 1;
    // LL(T);
    FOR(T) solve();
    
    return 0;
    }    
}

void abc253(){
    /**
    *    author:  tourist
    *    created: 28.05.2022 16:04:42       
    **/
    #include <bits/stdc++.h>

    using namespace std;

    #ifdef LOCAL
    #include "algo/debug.h"
    #else
    #define debug(...) 42
    #endif

    template <typename T>
    T inverse(T a, T m) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = m / a;
        m -= t * a; swap(a, m);
        u -= t * v; swap(u, v);
    }
    assert(m == 1);
    return u;
    }

    template <typename T>
    class Modular {
    public:
    using Type = typename decay<decltype(T::value)>::type;

    constexpr Modular() : value() {}
    template <typename U>
    Modular(const U& x) {
        value = normalize(x);
    }

    template <typename U>
    static Type normalize(const U& x) {
        Type v;
        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % mod());
        if (v < 0) v += mod();
        return v;
    }

    const Type& operator()() const { return value; }
    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }
    constexpr static Type mod() { return T::value; }

    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }
    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }
    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }
    Modular& operator++() { return *this += 1; }
    Modular& operator--() { return *this -= 1; }
    Modular operator++(int) { Modular result(*this); *this += 1; return result; }
    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }
    Modular operator-() const { return Modular(-value); }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {
    #ifdef _WIN32
        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);
        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;
        asm(
        "divl %4; \n\t"
        : "=a" (d), "=d" (m)
        : "d" (xh), "a" (xl), "r" (mod())
        );
        value = m;
    #else
        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));
    #endif
        return *this;
    }
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {
        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
        value = normalize(value * rhs.value - q * mod());
        return *this;
    }
    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {
        value = normalize(value * rhs.value);
        return *this;
    }

    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }

    friend const Type& abs(const Modular& x) { return x.value; }

    template <typename U>
    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename U>
    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename V, typename U>
    friend V& operator>>(V& stream, Modular<U>& number);

    private:
    Type value;
    };

    template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }
    template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }
    template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }

    template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
    template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }
    template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }

    template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }

    template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
    template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }
    template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }

    template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
    template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
    template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }

    template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
    template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
    template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }

    template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
    template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
    template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }

    template<typename T, typename U>
    Modular<T> power(const Modular<T>& a, const U& b) {
    assert(b >= 0);
    Modular<T> x = a, res = 1;
    U p = b;
    while (p > 0) {
        if (p & 1) res *= x;
        x *= x;
        p >>= 1;
    }
    return res;
    }

    template <typename T>
    bool IsZero(const Modular<T>& number) {
    return number() == 0;
    }

    template <typename T>
    string to_string(const Modular<T>& number) {
    return to_string(number());
    }

    // U == std::ostream? but done this way because of fastoutput
    template <typename U, typename T>
    U& operator<<(U& stream, const Modular<T>& number) {
    return stream << number();
    }

    // U == std::istream? but done this way because of fastinput
    template <typename U, typename T>
    U& operator>>(U& stream, Modular<T>& number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
    }

    /*
    using ModType = int;

    struct VarMod { static ModType value; };
    ModType VarMod::value;
    ModType& md = VarMod::value;
    using Mint = Modular<VarMod>;
    */

    constexpr int md = 998244353;
    using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;

    /*vector<Mint> fact(1, 1);
    vector<Mint> inv_fact(1, 1);

    Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
    }*/

    int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, k;
    cin >> n >> m >> k;
    vector<Mint> f(m, 1);
    for (int it = 1; it < n; it++) {
        vector<Mint> pref(m + 1);
        for (int i = 0; i < m; i++) {
        pref[i + 1] = pref[i] + f[i];
        }
        for (int i = 0; i < m; i++) {
        int L = max(0, i - k + 1);
        int R = min(m - 1, i + k - 1);
        if (k == 0) {
            f[i] = pref[m];
        } else {
            f[i] = pref[m] - (pref[R + 1] - pref[L]);
        }
        }
    }
    cout << accumulate(f.begin(), f.end(), Mint(0)) << '\n';
    return 0;
    }

}

void abc253e(){
    #include<bits/stdc++.h>
    #include<atcoder/all>

    using namespace std;

    using int64 = long long;
    // const int mod = 1e9 + 7;
    const int mod = 998244353;

    const int64 infll = (1LL << 62) - 1;
    const int inf = (1 << 30) - 1;

    struct IoSetup {
    IoSetup() {
        cin.tie(nullptr);
        ios::sync_with_stdio(false);
        cout << fixed << setprecision(10);
        cerr << fixed << setprecision(10);
    }
    } iosetup;


    template< typename T1, typename T2 >
    ostream &operator<<(ostream &os, const pair< T1, T2 > &p) {
    os << p.first << " " << p.second;
    return os;
    }

    template< typename T1, typename T2 >
    istream &operator>>(istream &is, pair< T1, T2 > &p) {
    is >> p.first >> p.second;
    return is;
    }

    template< typename T >
    ostream &operator<<(ostream &os, const vector< T > &v) {
    for(int i = 0; i < (int) v.size(); i++) {
        os << v[i] << (i + 1 != v.size() ? " " : "");
    }
    return os;
    }

    template< typename T >
    istream &operator>>(istream &is, vector< T > &v) {
    for(T &in: v) is >> in;
    return is;
    }

    template< typename T1, typename T2 >
    inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }

    template< typename T1, typename T2 >
    inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }

    template< typename T = int64 >
    vector< T > make_v(size_t a) {
    return vector< T >(a);
    }

    template< typename T, typename... Ts >
    auto make_v(size_t a, Ts... ts) {
    return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));
    }

    template< typename T, typename V >
    typename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {
    t = v;
    }

    template< typename T, typename V >
    typename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {
    for(auto &e: t) fill_v(e, v);
    }

    template< typename F >
    struct FixPoint : F {
    FixPoint(F &&f) : F(forward< F >(f)) {}

    template< typename... Args >
    decltype(auto) operator()(Args &&... args) const {
        return F::operator()(*this, forward< Args >(args)...);
    }
    };

    template< typename F >
    inline decltype(auto) MFP(F &&f) {
    return FixPoint< F >{forward< F >(f)};
    }

    int main() {
      int n, m, k;
      using mint = modint998244353;
      vector<mint> dp1(m, 1);
      for (int i = 1; i < n; i++) {
        vector<mint> dp2(m);
        for (int j = 0; j < m; j++) {
          if (k == 0) {
            dp2[0] += dp1[j];
            continue;
          }
          if (j + k < m) { dp2[j + k] += dp1[j]; }
          if (j - k >= 0) {
            dp2[0] += dp1[j];
            if (j - k + 1 < m) dp2[j - k + 1] -= dp1[j];
          }
        }
        for (int j = 1; j < m; j++) {
          dp2[j] += dp2[j - 1];
        }
        dp1 = dp2;
      }
      cout << accumulate(begin(dp1), end(dp1), mint()).val() << endl;
    }
}

abc253e2{
  #include <bits/stdc++.h>
  using namespace std;
  const long long MOD = 998244353;
  int main(){
    int N, M, K;
    cin >> N >> M >> K;
    vector<vector<long long>> dp(N, vector<long long>(M, 0));
    for (int i = 0; i < M; i++){
      dp[0][i] = 1;
    }
    for (int i = 0; i < N - 1; i++){
      vector<long long> S(M + 1);
      S[0] = 0;
      for (int j = 0; j < M; j++){
        S[j + 1] = S[j] + dp[i][j];
        S[j + 1] %= MOD;
      }
      for (int j = 0; j < M; j++){
        dp[i + 1][j] = S[M];
        if (K > 0){
          dp[i + 1][j] -= S[min(j + K, M)] - S[max(j - K + 1, 0)];
        }
        dp[i + 1][j] += MOD;
        dp[i + 1][j] %= MOD;
      }
    }
    long long ans = 0;
    for (int i = 0; i < M; i++){
      ans += dp[N - 1][i];
    }
    ans %= MOD;
    cout << ans << endl;
  }
}

abc175d(){

    #include <bits/stdc++.h>
    using namespace std;

    using ll = long long;
    using pii = pair<int, int>;
    template <class T>
    using V = vector<T>;
    template <class T>
    using VV = V<V<T>>;

    #define pb push_back
    #define eb emplace_back
    #define mp make_pair
    #define fi first
    #define se second
    #define rep(i, n) rep2(i, 0, n)
    #define rep2(i, m, n) for (int i = m; i < (n); i++)
    #define per(i, b) per2(i, 0, b)
    #define per2(i, a, b) for (int i = int(b) - 1; i >= int(a); i--)
    #define ALL(c) (c).begin(), (c).end()
    #define SZ(x) ((int)(x).size())

    constexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }

    template <class T, class U>
    void chmin(T& t, const U& u) {
        if (t > u) t = u;
    }
    template <class T, class U>
    void chmax(T& t, const U& u) {
        if (t < u) t = u;
    }

    template <class T, class U>
    ostream& operator<<(ostream& os, const pair<T, U>& p) {
        os << "(" << p.first << "," << p.second << ")";
        return os;
    }

    template <class T>
    ostream& operator<<(ostream& os, const vector<T>& v) {
        os << "{";
        rep(i, v.size()) {
            if (i) os << ",";
            os << v[i];
        }
        os << "}";
        return os;
    }

    #ifdef LOCAL
    void debug_out() { cerr << endl; }
    template <typename Head, typename... Tail>
    void debug_out(Head H, Tail... T) {
        cerr << " " << H;
        debug_out(T...);
    }
    #define debug(...) \
        cerr << __LINE__ << " [" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
    #define dump(x) cerr << __LINE__ << " " << #x << " = " << (x) << endl
    #else
    #define debug(...) (void(0))
    #define dump(x) (void(0))
    #endif

    constexpr ll INF = TEN(18);

    int main() {
        int N, K;
        cin >> N >> K;
        V<int> P(N), C(N);
        rep(i, N) cin >> P[i], --P[i];
        rep(i, N) cin >> C[i];

        ll ans = -INF;

        rep(i, N) {
            int v = i;
            ll cycle_sum = 0;
            int cycle_cnt = 0;

            while (true) {
                cycle_cnt++;
                cycle_sum += C[v];
                v = P[v];
                if (v == i) break;
            }

            ll path = 0;
            int cnt = 0;

            while (true) {
                cnt++;
                path += C[v];

                if (cnt > K) break;

                int num = (K - cnt) / cycle_cnt;
                ll score = path + max(0ll, cycle_sum) * num;
                chmax(ans, score);

                v = P[v];
                if (v == i) break;
            }
        }

        cout << ans << endl;

        return 0;
    }
}

abc253a(){
  #include <bits/stdc++.h>
  using namespace std;

  int main() {
      int a, b, c;
      cin >> a >> b >> c;
      if ((a <= b and b <= c) or (a >= b and b >= c)) {
          cout << "Yes\n";
      } else {
          cout << "No\n";
      }
      return 0;
  }

}

abc253b(){
  #include <bits/stdc++.h>
  using namespace std;

  int main() {
      int h, w;
      cin >> h >> w;
      vector<pair<int, int>> pieces;
      for (int i = 0; i < h; ++i) {
          for (int j = 0; j < w; ++j) {
              char c;
              cin >> c;
              if (c == 'o') {
                  pieces.emplace_back(i, j);
              }
          }
      }
      const auto& [a, b] = pieces[0];
      const auto& [c, d] = pieces[1];
      cout << abs(a - c) + abs(b - d) << '\n';
      return 0;
  }

}

abc253e2(){
  ll n,m,k;cin>>n>>m>>k;
    
  if(k==0){
      cout<<mint(m).pow(n).val()<<endl;
      return 0;
  }
  auto sm=[](vi a){
      vi b=a;
      rep(i,1,(int)b.size()-1){
          b[i] += b[i-1];
      }
      return b;
  };
  vi dp(m+1);
  rep(i,1,m)dp[i]=1;
  vi dps=sm(dp);
  rep(zz,1,n-1){
      vi nx(m+1);
      rep(i,1,m){
          nx[i] += dps[m];
          if(i+k-1<=m)nx[i] -= dps[i+k-1];
          else nx[i] -= dps[m];
          if(i-k>=0)nx[i] += dps[i-k];
      }
      dp=nx;
      dps=sm(dp);
      /*rep(i,0,m){
          cout<<dp[i].val()<<" ";
      }cout<<endl;*/
  }
  cout<<dps[m].val()<<endl;
  
  return 0;
}

abc174c(){
  int a[1000001];
  int K;
  scanf("%d",&K);
  a[1]=7%K;
  for(int i=2;i<=K;i++)a[i]=(a[i-1]*10+7)%K;
  
  for(int i=1;i<=K;i++)if(a[i]==0){
    printf("%d\n",i);
    return 0;
  }
  printf("-1\n");
}

abc253f(){
  #include <bits/stdc++.h>
  #include <atcoder/fenwicktree>
  using namespace std;

  int main() {
    int n, m, q;
    cin >> n >> m >> q;
    vector<int> t(q), a(q), b(q), c(q);
    vector<vector<int>> subt(q);
    vector latest(n, pair(-1, 0));
    vector<long long> ans;
    for (int i = 0; i < q; ++i) {
      cin >> t[i];
      if (t[i] == 1) {
        cin >> a[i] >> b[i] >> c[i];
        a[i] -= 1;
      } else if (t[i] == 2) {
        cin >> a[i] >> b[i];
        a[i] -= 1;
        latest[a[i]] = pair(i, b[i]);
      } else {
        cin >> a[i] >> b[i];
        a[i] -= 1;
        const auto& [j, x] = latest[a[i]];
        const int id = ans.size();
        ans.emplace_back(x);
        c[i] = id;
        if (j >= 0) {
          subt[j].push_back(i);
        }
      }
    }
    atcoder::fenwick_tree<long long> fen(m + 1);
    for (int i = 0; i < q; ++i) {
      if (t[i] == 1) {
        fen.add(a[i], c[i]);
        fen.add(b[i], -c[i]);
      } else if (t[i] == 2) {
        for (const int j : subt[i]) {
          ans[c[j]] -= fen.sum(0, b[j]);
        }
      } else {
        ans[c[i]] += fen.sum(0, b[i]);
      }
    }
    for (const long long x : ans) {
      cout << x << '\n';
    }
    return 0; 
  }
}

abc252c(){
  #include <bits/stdc++.h>
  using namespace std;

  int main(void) {
    int n;
    string s[100];
    int cnt[10][10];
    int ans, mx;
    for (int i = 0; i < 10; i++) {
      for (int j = 0; j < 10; j++)cnt[i][j] = 0;
    }

    cin >> n;
    for (int i = 0; i < n; i++)cin >> s[i];

    for (int i = 0; i < n; i++) {
      for (int j = 0; j < 10; j++) {
        cnt[(s[i][j] - '0')][j]++;
      }
    }

    ans = 1000;
    for (int i = 0; i < 10; i++) {
      mx = 0;
      for (int j = 0; j < 10; j++) {
        mx = max(mx, 10 * (cnt[i][j] - 1) + j);
      }
      ans = min(ans, mx);
    }

    cout << ans << endl;

    return 0;
  }

}

abc252d2(){
  #include<stdio.h>

  int c[200010];
  int main(){
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
      int t;
      scanf("%d",&t);
      c[t]++;
    }
    
    long long ans=0;
    long long small=0;
    for(int i=1;i<=200000;i++){
      ans+=small*c[i]*(n-small-c[i]);
      small+=c[i];
    }
    
    printf("%lld\n",ans);
  }
}

abc252e(){
  #include <bits/stdc++.h>
  using namespace std;

  int main(void) {
    int n;
    priority_queue<long long, vector<long long>, greater<long long> >pq;
    long long x, y, l;
    long long ans = 0;

    cin >> n >> l;
    for (int i = 0; i < n; i++) {
      cin >> x;
      l -= x;
      pq.push(x);
    }

    if (l > 0) {
      pq.push(l);
      n++;
    }
    for (int i = 0; i < (n - 1); i++) {
      x = pq.top();
      pq.pop();
      y = pq.top();
      pq.pop();
      ans += x + y;
      pq.push(x + y);
    }

    cout << ans << endl;
    return 0;
  }

}

abc254d(){
  #include <bits/stdc++.h>
  using namespace std;
  int main(){
    int n;
    cin>>n;
    vector<bool> sq(n+1,false);
    for(int i=1;i*i<=n;i++) sq[i*i]=true;
    vector<vector<int>> d(n+1);
    for(int i=1;i<=n;i++){
      for(int j=i;j<=n;j+=i) d[j].push_back(i);
    }
    vector<int> cnt(n+1);
    for(int i=1;i<=n;i++){
      int f=0;
      for(int j=0;j<d[i].size();j++) if(sq[d[i][j]]) f=d[i][j];
      cnt[i/f]++;
    }
    int ans=0;
    for(int i=1;i<=n;i++) ans+=cnt[i]*cnt[i];
    cout<<ans<<endl;
  }

}

abc254d2(){
  #define ll long long
  int main(){
    int n;
    scanf("%d",&n);
    ll ans=0;
    for(ll i=1;i<=n;i++){
      ll k=i;
      for(ll d=2;d*d<=k;d++){
        while(k%(d*d)==0)k/=d*d;
      }
      for(ll d=1;k*d*d<=n;d++)ans++;
    }
    printf("%lld",ans);
  }

}

abc254e(){
  #include <bits/stdc++.h>
  using namespace std;

  int main() {
      
    int N,M;
    cin>>N>>M;
    vector<vector<int>> E(N);
    for(int i=0;i<M;i++){
      int a,b;
      cin>>a>>b;
      a--,b--;
      E[a].push_back(b);
      E[b].push_back(a);
    }
    
    vector<int> dis(N,-1);
    
    int Q;
    cin>>Q;
    
    for(int i=0;i<Q;i++){
      int x,k;
      cin>>x>>k;
      x--;
      queue<int> q;
      q.push(x);
      dis[x] = 0;
      vector<int> vs;
      while(q.size()>0){
        int u = q.front();
        q.pop();
        vs.push_back(u);
        if(dis[u]==k){
          continue;
        }
        for(int j=0;j<E[u].size();j++){
          int v = E[u][j];
          if(dis[v]!=-1)continue;
          dis[v] = dis[u] + 1;
          q.push(v);
        }
      }
      int ans = 0;
      for(int j=0;j<vs.size();j++){
        ans += vs[j]+1;
        dis[vs[j]] = -1;
      }
      cout<<ans<<endl;
    }
    
      return 0;
  }

}

abc254f(){
  #include <bits/stdc++.h>
  using namespace std;
  int f(int a, int b){
    return gcd(a, b);
  }
  template <typename T>
  struct segment_tree{
    int N;
    vector<T> ST;
    function<T(T, T)> f;
    T E;
    segment_tree(vector<T> A, function<T(T, T)> f, T E): f(f), E(E){
      int n = A.size();
      N = 1;
      while (N < n){
        N *= 2;
      }
      ST = vector<T>(N * 2 - 1, E);
      for (int i = 0; i < n; i++){
        ST[N - 1 + i] = A[i];
      }
      for (int i = N - 2; i >= 0; i--){
        ST[i] = f(ST[i * 2 + 1], ST[i * 2 + 2]);
      }
    }
    T query(int L, int R, int i, int l, int r){
      if (R <= l || r <= L){
        return E;
      } else if (L <= l && r <= R){
        return ST[i];
      } else {
        int m = (l + r) / 2;
        return f(query(L, R, i * 2 + 1, l, m), query(L, R, i * 2 + 2, m, r));
      }
    }
    T query(int L, int R){
      return query(L, R, 0, 0, N);
    }
  };
  int main(){
    int N, Q;
    cin >> N >> Q;
    vector<int> A(N);
    for (int i = 0; i < N; i++){
      cin >> A[i];
    }
    vector<int> B(N);
    for (int i = 0; i < N; i++){
      cin >> B[i];
    }
    vector<int> C(N - 1), D(N - 1);
    for (int i = 0; i < N - 1; i++){
      C[i] = abs(A[i + 1] - A[i]);
      D[i] = abs(B[i + 1] - B[i]);
    }
    segment_tree<int> ST1(C, f, 0);
    segment_tree<int> ST2(D, f, 0);
    for (int i = 0; i < Q; i++){
      int h1, h2, w1, w2;
      cin >> h1 >> h2 >> w1 >> w2;
      h1--;
      w1--;
      int x = ST1.query(h1, h2 - 1);
      int y = ST2.query(w1, w2 - 1);
      cout << gcd(gcd(x, y), A[h1] + B[w1]) << endl;
    }
  }
}

253e(){
  int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, k;
    cin >> n >> m >> k;
    vector<Mint> f(m, 1);
    for (int it = 1; it < n; it++) {
      vector<Mint> pref(m + 1);
      for (int i = 0; i < m; i++) {
        pref[i + 1] = pref[i] + f[i];
      }
      for (int i = 0; i < m; i++) {
        int L = max(0, i - k + 1);
        int R = min(m - 1, i + k - 1);
        if (k == 0) {
          f[i] = pref[m];
        } else {
          f[i] = pref[m] - (pref[R + 1] - pref[L]);
        }
      }
    }
    cout << accumulate(f.begin(), f.end(), Mint(0)) << '\n';
    return 0;
  }
}

abc173c(){
  #include<bits/stdc++.h>
  #define rep(i,a,b) for(int i=a;i<b;i++)
  #define rrep(i,a,b) for(int i=a;i>=b;i--)
  #define fore(i,a) for(auto &i:a)
  #define all(x) (x).begin(),(x).end()
  //#pragma GCC optimize ("-O3")
  using namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }
  typedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;
  template<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }
  template<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }
  //---------------------------------------------------------------------------------------------------
  int H, W, K;
  string c[6];
  string c2[6];
  //---------------------------------------------------------------------------------------------------
  void _main() {
    cin >> H >> W >> K;
    rep(y, 0, H) cin >> c[y];

    int ans = 0;
    rep(mskH, 0, 1 << H) rep(mskW, 0, 1 << W) {
      rep(y, 0, H) c2[y] = c[y];
      rep(y, 0, H) if (mskH & (1 << y)) rep(x, 0, W) c2[y][x] = 'R';
      rep(x, 0, W) if (mskW & (1 << x)) rep(y, 0, H) c2[y][x] = 'R';

      int cnt = 0;
      rep(x, 0, W) rep(y, 0, H) if (c2[y][x] == '#') cnt++;
      if (cnt == K) ans++;
    }
    cout << ans << endl;
  }

}

abc255b{
  #include<bits/stdc++.h>

  using namespace std;

  int main(){
    int n,k;
    cin >> n >> k;
    vector<int> a(k);
    for(auto &nx : a){
      cin >> nx;
      nx--;
    }
    vector<long long> x(n),y(n);
    for(int i=0;i<n;i++){cin >> x[i] >> y[i];}

    long long res=0;
    for(int i=0;i<n;i++){
      long long cres=8e18;
      for(auto &nx : a){
        cres=min(cres,(x[i]-x[nx])*(x[i]-x[nx]) + (y[i]-y[nx])*(y[i]-y[nx]));
      }
      res=max(res,cres);
    }
    printf("%.12lf\n",sqrt((double)res));
    return 0;
  }


}

abc255d{
  #include<bits/stdc++.h>

  using namespace std;

  int main(){
    int n,q;
    cin >> n >> q;
    vector<long long> a(n);
    for(auto &nx : a){cin >> nx;}
    sort(a.begin(),a.end());

    vector<long long> rw(n+1,0);
    for(long long i=0;i<n;i++){rw[i+1]=rw[i]+a[i];}

    for(int i=0;i<q;i++){
      long long x;
      cin >> x;
      int st=0,fi=n-1;
      while(st<=fi){
        int te=(st+fi)/2;
        if(a[te]<x){st=te+1;}
        else{fi=te-1;}
      }
      long long res=x*st;
      res-=rw[fi+1];
      res+=(rw[n]-rw[st]);
      res-=x*(n-st);
      cout << res << '\n';
    }
    return 0;
  }

}

abc255e{
  #include <iostream>
  #include <map>
  using namespace std;
  typedef long long ll;

  ll n, m;
  ll s[200005], x[15];
  ll b[200005];

  int main(void)
  {
    cin >> n >> m;
    for(int i = 1; i <= n-1; i++) cin >> s[i];
    for(int i = 1; i <= m; i++) cin >> x[i];
    
    for(int i = 2; i <= n; i++) b[i] = s[i-1] - b[i-1];
    
    map<ll, ll> mp;
    for(int i = 1; i <= n; i++){
      for(int j = 1; j <= m; j++){
        ll c = x[j] - b[i];
        if(i % 2 == 0) c *= -1;
        mp[c]++;
      }
    }
    
    ll ans = 0;
    for(auto p : mp) ans = max(ans, p.second);
    cout << ans << endl;
    
    return 0;
  }

}

abc254d{
  
  int n;
  cin >> n;
  ll ans = 0;

  REP2(i, 1, n) {
    ll k = i;
    for (ll d = 2; d * d <= k; d++) {
      while (k % (d * d) == 0)
        k /= d * d;
    }
    for (ll d = 1; k * d * d <= n; d++)
      ans++;
  }
  cout << ans << endl;
}

edu1{
  #include <iostream>
  using namespace std;

  long long N, K, L;
  long long A[1 << 18];

  bool solve(long long M) {
      long long cnt = 0, pre = 0;
      for (int i = 1; i <= N; i++) {
          if (A[i] - pre >= M && L - A[i] >= M) {
              cnt += 1;
              pre = A[i];
          }
      }
      if (cnt >= K) return true;
      return false;
  }

  int main() {
      // Step #1. 入力
      cin >> N >> L;
      cin >> K;
      for (int i = 1; i <= N; i++) {
          cin >> A[i];
      }
      
      // Step #2. 答えで二分探索（めぐる式二分探索法）
      // https://qiita.com/drken/items/97e37dd6143e33a64c8c
      long long left = -1;
      long long right = L + 1;
      while (right - left > 1) {
          long long mid = left + (right - left) / 2;
          if (solve(mid) == false) right = mid;
          else left = mid;
      }
      cout << left << endl;
      return 0;
  }
}

edu2{
  #include <iostream>
  #include <string>
  using namespace std;

  bool hantei(string S) {
    int dep = 0;
    for (int i = 0; i < S.size(); i++) {
      if (S[i] == '(') dep += 1;
      if (S[i] == ')') dep -= 1;
      if (dep < 0) return false;
    }
    if (dep == 0) return true;
    return false;
  }

  int main() {
    int N;
    cin >> N;
    for (int i = 0; i < (1 << N); i++) {
      string Candidate = "";
      for (int j = N - 1; j >= 0; j--) {
        // メモ : (i & (1 << j)) = 0 というのは、i の j ビット目（2^j の位）が 0 であるための条件。
        // 　　　頻出なので知っておくようにしましょう。
        if ((i & (1 << j)) == 0) {
          Candidate += "(";
        }
        else {
          Candidate += ")";
        }
      }
      bool I = hantei(Candidate);
      if (I == true) cout << Candidate << endl;
    }
    return 0;
  }
}

edu3{
  #include <iostream>
  #include <vector>
  #include <queue>
  using namespace std;

  // 入力
  int N;
  int A[1 << 18], B[1 << 18];

  // グラフ
  const int INF = (1 << 29);
  vector<int> G[1 << 18];
  int dist[1 << 18];

  void getdist(int start) {
    // 幅優先探索（BFS）により、最短距離を計算
    for (int i = 1; i <= N; i++) dist[i] = INF;

    queue<int> Q;
    Q.push(start);
    dist[start] = 0;

    while (!Q.empty()) {
      int pos = Q.front(); Q.pop();
      for (int to : G[pos]) {
        if (dist[to] == INF) {
          dist[to] = dist[pos] + 1;
          Q.push(to);
        }
      }
    }
  }

  int main() {
    // Step #1. 入力
    cin >> N;
    for (int i = 1; i <= N - 1; i++) {
      cin >> A[i] >> B[i];
      G[A[i]].push_back(B[i]);
      G[B[i]].push_back(A[i]);
    }

    // Step #2. 頂点 1 からの最短距離を求める
    // maxid1: 頂点 1 から最も離れている（最短距離が長い）頂点
    getdist(1);
    int maxn1 = -1, maxid1 = -1;
    for (int i = 1; i <= N; i++) {
      if (maxn1 < dist[i]) {
        maxn1 = dist[i];
        maxid1 = i;
      }
    }

    // Step #3. 頂点 maxid1 からの最短距離を求める
    // maxn2: 木の直径（最短距離の最大値）
    getdist(maxid1);
    int maxn2 = -1;
    for (int i = 1; i <= N; i++) {
      maxn2 = max(maxn2, dist[i]);
    }

    // Step #4. 出力
    cout << maxn2 + 1 << endl;
    return 0;
  }
}

edu4{
  int h, w;
  cin >> h >> w;
  vvi A(h, vi(w));
  cin >> A;
  vvi B(h, vi(w, 0));
  vi row_sum(h);
  rep(i, h) {
    rep(j, w) {
      row_sum[i] += A[i][j];
    }
  }
  vi col_sum(w);
  rep(i, w) {
    rep(j, h) {
      col_sum[i] += A[j][i];
    }
  }
  rep(i, h) {
    rep(j, w) {
      B[i][j] = row_sum[i] + col_sum[j] - A[i][j];
      cout << B[i][j] << " \n"[j == w - 1];
    }
  }
}

edu5{
  #include <iostream>
  using namespace std;

  long long modpow(long long a, long long b, long long m) {
    long long p = 1, q = a;
    for (int i = 0; i < 63; i++) {
      if ((b & (1LL << i)) != 0) {
        p *= q;
        p %= m;
      }
      q *= q;
      q %= m;
    }
    return p;
  }

  const long long mod = 1000000007;

  // 入力
  long long N, B, K;
  long long C[11];

  // その他の変数
  long long power10[64];
  long long DP[64][1009];
  long long Answer[64][1009];

  int main() {
    // Step #1. 入力
    cin >> N >> B >> K;
    for (int i = 1; i <= K; i++) cin >> C[i];
    
    // Step #2. 前計算
    for (int i = 0; i <= 62; i++) {
      power10[i] = modpow(10LL, (1LL << i), B);
    }
    
    // Step #3. dp[1][i] を求める
    for (int i = 1; i <= K; i++) {
      DP[0][C[i] % B] += 1;
    }

    // Step #4. dp[1][i], dp[2][i], ..., dp[2^n][i] を求める
    for (int i = 0; i < 62; i++) {
      for (int j = 0; j < B; j++) {
        for (int k = 0; k < B; k++) {
          int nex = (j * power10[i] + k) % B;
          DP[i + 1][nex] += DP[i][j] * DP[i][k];
          DP[i + 1][nex] %= mod;
        }
      }
    }

    // Step #5. 繰り返し二乗法により dp[N][i] を求める
    Answer[0][0] = 1;
    for (int i = 0; i < 62; i++) {
      if ((N & (1LL << i)) != 0LL) {
        for (int j = 0; j < B; j++) {
          for (int k = 0; k < B; k++) {
            int nex = (j * power10[i] + k) % B;
            Answer[i + 1][nex] += Answer[i][j] * DP[i][k];
            Answer[i + 1][nex] %= mod;
          }
        }
      }
      else {
        for (int j = 0; j < B; j++) Answer[i + 1][j] = Answer[i][j];
      }
    }

    // Step #6. 出力
    cout << Answer[62][0] << endl;
    return 0;
  }
}

edu6{
  #include <iostream>
  using namespace std;

  string S;
  int N,K;
  int nex[100009][26];

  int main() {
    // Step #1. 入力
    cin >> N >> K;
    cin >> S;

    // Step #2. 前計算
    for (int i = 0; i < 26; i++) nex[S.size()][i] = S.size();
    for (int i = (int)S.size() - 1; i >= 0; i--) {
      for (int j = 0; j < 26; j++) {
        if ((int)(S[i] - 'a') == j) {
          nex[i][j] = i;
        }
        else {
          nex[i][j] = nex[i + 1][j];
        }
      }
    }

    // Step #3. 一文字ずつ貪欲に決める
    string Answer = "";
    int CurrentPos = 0;
    for (int i = 1; i <= K; i++) {
      for (int j = 0; j < 26; j++) {
        int NexPos = nex[CurrentPos][j];
        int MaxPossibleLength = (int)(S.size() - NexPos - 1) + i;
        if (MaxPossibleLength >= K) {
          Answer += (char)('a' + j);
          CurrentPos = NexPos + 1;
          break;
        }
      }
    }

    // Step #4. 出力
    cout << Answer << endl;
    return 0;
  }
}

edu7{
  #include <iostream>
  #include <algorithm>
  #include <cmath>
  using namespace std;

  const int INF = 2000000000;
  int N;
  int A[300009];
  int Q;
  int B[300009];

  int main() {
    // Step #1. Input
    cin >> N;
    for (int i = 1; i <= N; i++) cin >> A[i];
    cin >> Q;
    for (int i = 1; i <= Q; i++) cin >> B[i];

    // Step #2. Sorting
    sort(A + 1, A + N + 1);

    // Step #3. Binary Search
    for (int i = 1; i <= Q; i++) {
      int pos1 = lower_bound(A + 1, A + N + 1, B[i]) - A;
      int Diff1 = INF, Diff2 = INF;
      if (pos1 <= N) Diff1 = abs(B[i] - A[pos1]);
      if (pos1 >= 2) Diff2 = abs(B[i] - A[pos1 - 1]);
      cout << min(Diff1, Diff2) << endl;
    }
    return 0;
  }
}

abc8{
  #include <iostream>
  using namespace std;

  string S;
  long long mod = 1000000007;
  long long dp[100009][8];

  int main() {
    // Step #1. Input
    int N;
    cin >> N;
    cin >> S;

    // Step #2. Dynamic Programming (DP)
    dp[0][0] = 1;
    for (int i = 0; i < (int)S.size(); i++) {
      for (int j = 0; j <= 7; j++) {
        dp[i + 1][j] += dp[i][j];
        if (S[i] == 'a' && j == 0) dp[i + 1][j + 1] += dp[i][j];
        if (S[i] == 't' && j == 1) dp[i + 1][j + 1] += dp[i][j];
        if (S[i] == 'c' && j == 2) dp[i + 1][j + 1] += dp[i][j];
        if (S[i] == 'o' && j == 3) dp[i + 1][j + 1] += dp[i][j];
        if (S[i] == 'd' && j == 4) dp[i + 1][j + 1] += dp[i][j];
        if (S[i] == 'e' && j == 5) dp[i + 1][j + 1] += dp[i][j];
        if (S[i] == 'r' && j == 6) dp[i + 1][j + 1] += dp[i][j];
      }
      for (int j = 0; j <= 7; j++) dp[i + 1][j] %= mod;
    }

    // Step #3. Output the answer
    cout << dp[S.size()][7] << endl;
    return 0;
  }
}

edu9{
  #include <iostream>
  #include <cmath>
  #include <vector>
  #include <algorithm>
  using namespace std;

  struct Point {
    double px, py;
  };

  Point operator-(const Point& a1, const Point& a2) {
    return Point{ a1.px - a2.px, a1.py - a2.py };
  }

  double getangle(Point G) {
    // 点 G の偏角を求める
    if (G.py >= 0.0) {
      double I = G.px / sqrt(G.px * G.px + G.py * G.py);
      double kaku = acos(I) * 180.0 / 3.14159265358979;
      return kaku;
    }
    else {
      double I = G.px / sqrt(G.px * G.px + G.py * G.py);
      double kaku = acos(I) * 180.0 / 3.14159265358979;
      return 360.0 - kaku;
    }
  }

  double getangle2(double I1, double I2) {
    // [偏角 I1] - [原点] - [偏角 I2] のなす角度を求める
    // 例えば I1 = 240°、I2 = 30°のとき、求める角度は 150°
    double res = abs(I1 - I2);
    if (res >= 180.0) return 360.0 - res;
    return res;
  }

  int N;
  Point G[2009];

  double solve(int pos) {
    // 最初に偏角の昇順にソートする
    vector<double> vec;
    for (int i = 1; i <= N; i++) {
      if (i == pos) continue;
      Point SA = G[i] - G[pos];
      double angle = getangle(SA);
      vec.push_back(angle);
    }
    sort(vec.begin(), vec.end());

    // 点 A を全探索して、最も偏角の大きくなる点 C を二分探索（std::lower_bound）で求める
    double ret = 0.0;
    for (int i = 0; i < vec.size(); i++) {
      double target = vec[i] + 180.0;
      if (target >= 360.0) target -= 360.0;
      int pos1 = lower_bound(vec.begin(), vec.end(), target) - vec.begin();

      // 点 C の候補は高々 2 つに絞れる
      int CandIdx1 = pos1 % vec.size();
      int CandIdx2 = (pos1 + vec.size() - 1) % vec.size();
      double Candidate1 = getangle2(vec[i], vec[CandIdx1]);
      double Candidate2 = getangle2(vec[i], vec[CandIdx2]);
      ret = max({ ret, Candidate1, Candidate2 });
    }
    return ret;
  }

  // O(N^3) のアルゴリズム（点 A, B, C を全探索）
  double solve_Slow() {
    double Answer = 0.0;
    for (int i = 1; i <= N; i++) {
      for (int j = 1; j <= N; j++) {
        for (int k = 1; k <= N; k++) {
          if (i == j || i == k || j == k) continue;
          double I1 = getangle(G[i] - G[j]);
          double I2 = getangle(G[k] - G[j]);
          Answer = max(Answer, getangle2(I1, I2));
        }
      }
    }
    return Answer;
  }

  // O(N^2 log N) のアルゴリズム
  double solve_Fast() {
    // 点 B を全探索
    double Answer = 0.0;
    for (int i = 1; i <= N; i++) {
      double ret = solve(i);
      Answer = max(Answer, ret);
    }
    return Answer;
  }

  int main() {
    // Step #1. 入力
    cin >> N;
    for (int i = 1; i <= N; i++) {
      cin >> G[i].px >> G[i].py;
    }

    // Step #2. 出力
    double FinalAns = solve_Fast();
    printf("%.12lf\n", FinalAns);
    return 0;
  }
}

edu10{
  #include <iostream>
  using namespace std;

  // 入力
  int N;
  int C[100009], P[100009];
  int Q;
  int L[100009], R[100009];

  // 累積和
  int Sum1[100009];
  int Sum2[100009];

  int main() {
    // Step #1. 入力
    cin >> N;
    for (int i = 1; i <= N; i++) cin >> C[i] >> P[i];
    cin >> Q;
    for (int i = 1; i <= Q; i++) cin >> L[i] >> R[i];

    // Step #2. 1 組・2 組それぞれの累積和を取る
    for (int i = 1; i <= N; i++) {
      Sum1[i] = Sum1[i - 1];
      Sum2[i] = Sum2[i - 1];
      if (C[i] == 1) Sum1[i] += P[i];
      if (C[i] == 2) Sum2[i] += P[i];
    }

    // Step #3. クエリに答える
    for (int i = 1; i <= Q; i++) {
      int Answer1 = Sum1[R[i]] - Sum1[L[i] - 1];
      int Answer2 = Sum2[R[i]] - Sum2[L[i] - 1];
      cout << Answer1 << " " << Answer2 << endl;
    }
    return 0;
  }
}

abc256e{
  #include <iostream>
  #include <vector>
  using namespace std;

  #include "atcoder/dsu.hpp"

  int main() {
    int N;
    cin >> N;
    vector<int> X(N), C(N);
    for (auto& x : X) cin >> x, --x;
    for (auto& x : C) cin >> x;
    atcoder::dsu uf(N);
    long long ans = 0;
    for (int i = 0; i < N; i++) {
      if (uf.same(i, X[i]) == false) {
        uf.merge(i, X[i]);
        continue;
      }
      int cur = C[i], v = i;
      do {
        v = X[v];
        cur = min(cur, C[v]);
      } while (v != i);
      ans += cur;
    }
    cout << ans << "\n";
  }

}

abc256f{
  #include<bits/stdc++.h>
  #include<atcoder/all>
  using namespace std;
  using namespace atcoder;
  using mint=modint998244353;

  using S=array<mint,3>;
  S e(){return S();}
  S op(S x,S y){return {x[0]+y[0],x[1]+y[1],x[2]+y[2]};}

  int main(){
    int n,q;
    cin >> n >> q;
    vector<S>a(n);
    for(int i=0;i<n;i++){
      int t;
      cin >> t;
      a[i]={mint(t),mint(t)*i,mint(t)*i*i};
    }
    
    segtree<S,op,e>seg(a);
    
    while(q--){
      int t,x;
      cin >> t >> x;
      x--;
      if(t==1){
        int y;
        cin >> y;
        seg.set(x,{mint(y),mint(y)*x,mint(y)*x*x});
      }else{
        S ret=seg.prod(0,x+1);
        cout << (ret[2]/2-ret[1]*(2*x+3)/2+ret[0]*(x+1)*(x+2)/2).val() << endl;
      }
    }
  }

}

aclj{
  #include <atcoder/segtree>
  #include <cstdio>
  #include <vector>

  using namespace std;
  using namespace atcoder;

  int op(int a, int b) { return max(a, b); }

  int e() { return -1; }

  int target;

  bool f(int v) { return v < target; }

  int main() {
      int n, q;
      scanf("%d %d", &n, &q);
      vector<int> a(n);
      for (int i = 0; i < n; i++) {
          scanf("%d", &(a[i]));
      }

      segtree<int, op, e> seg(a);

      for (int i = 0; i < q; i++) {
          int t;
          scanf("%d", &t);
          if (t == 1) {
              int x, v;
              scanf("%d %d", &x, &v);
              x--;
              seg.set(x, v);
          } else if (t == 2) {
              int l, r;
              scanf("%d %d", &l, &r);
              l--;
              printf("%d\n", seg.prod(l, r));
          } else if (t == 3) {
              int p;
              scanf("%d %d", &p, &target);
              p--;
              printf("%d\n", seg.max_right<f>(p) + 1);
          }
      }
  }
}

abc256d{
  #include<stdio.h>

  int a[200010];
  int main(){
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
      int l,r;
      scanf("%d%d",&l,&r);
      a[l]++;
      a[r]--;
    }
    for(int i=1;i<=200005;i++)a[i]+=a[i-1];
    for(int i=1;i<=200005;i++){
      if(a[i-1]==0&&a[i]!=0)printf("%d ",i);
      if(a[i-1]!=0&&a[i]==0)printf("%d\n",i);
    }
  }
}

abc256f2{
  #include <bits/stdc++.h>
  #include <atcoder/all>
  using namespace std;
  using namespace atcoder;
  using ll=long long;
  const ll mod=998244353;
  #define rep(i,a) for (ll i=0;i<a;i++)


  ll R=(mod+1)/2;
  struct lazy_S {
      ll E;
      ll F;
      ll size;
  };

  using lazy_F = ll;

  lazy_S lazy_op(lazy_S l, lazy_S r) {
      return lazy_S{
          (l.E+r.E+(l.F*r.size)%mod)%mod,(l.F+r.F)%mod,l.size+r.size
      };
  }

  lazy_S lazy_e() { return lazy_S{0, 0, 0}; }

  lazy_S mapping(lazy_F l, lazy_S r) {
      l%=mod;
      if(l==0) return r;
      ll tmp=(r.size*(r.size+1))%mod;
      tmp*=(l*R)%mod;
      tmp%=mod;
      return lazy_S{
          (r.E+tmp)%mod,(r.F+(l*r.size)%mod)%mod,r.size
      };
  }

  //l(r(x))
  lazy_F composition(lazy_F l, lazy_F r) {
      return (l+r)%mod;
  }

  lazy_F lazy_id(){return 0;}

  #define lazy_calc lazy_S,lazy_op,lazy_e,lazy_F,mapping,composition,lazy_id


  void solve();
  // oddloop
  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      
      int t=1;
      //cin>>t;
      rep(i,t) solve();
  }

  void solve(){
      int N,Q;
      cin>>N>>Q;
      lazy_segtree<lazy_calc> seg(N);
      vector<ll> A(N);
      rep(i,N) seg.set(i,{0,0,1});
      rep(i,N){
          ll a;
          cin>>a;
          A[i]=a;
          seg.apply(i,N,a);
      }
      rep(i,Q){
          int t;
          cin>>t;
          if(t==1){
              ll x,v;
              cin>>x>>v;
              x--;
              seg.apply(x,N,v-A[x]);
              A[x]=v;
          }else{
              ll x;
              cin>>x;
              cout<<(mod+seg.prod(0,x).E)%mod<<"\n";
          }
      }
  }



}

abc255c{
  #include<bits/stdc++.h>

  using namespace std;

  int main(){
    long long x,a,d,n;
    cin >> x >> a >> d >> n;

    if(d<0){
      long long fi=a+d*(n-1);
      a=fi;
      d*=-1;
    }

    long long st=0,fi=(n-1);
    while(st<=fi){
      long long te=(st+fi)/2;
      if((a+d*te)<x){st=te+1;}
      else{fi=te-1;}
    }
    long long res=8e18;
    for(long long i=max(0ll,st-5);i<=min((n-1),st+5);i++){
      res=min(abs(a+d*i-x),res);
    }
    cout << res << '\n';
    return 0;
  }

}

abc171b{
  int N, K, p[1010];
  //---------------------------------------------------------------------------------------------------
  void _main() {
      cin >> N >> K;
      rep(i, 0, N) cin >> p[i];

      int ans = 0;
      sort(p, p + N);
      rep(i, 0, K) ans += p[i];
      cout << ans << endl;
  }
}

abc171c{
  #include <bits/stdc++.h>
  using namespace std;

  int main() {
      long long N;
      cin >> N;
      string res = "";
      while (N) {
          --N;
          res += (char)('a' + (N % 26));
          N /= 26;
      }
      reverse(res.begin(), res.end());
      cout << res << endl;
  }
}

abc256d{
  int main() {
    int n;
    cin >> n;
    vpi kukan;
    rep(i, n) {
      int l, r;
      cin >> l >> r;
      kukan.push_back({l, r});
    }
    sort(all(kukan));
    vpi ans;
    rep(i, n) {
      int left = kukan[i].first;
      int right = kukan[i].second;
      int index = i + 1;
      while (index < n && kukan[index].first <= right) {
        right = max(kukan[index].second, right);
        i = index;
        index++;
      }
      ans.push_back({left, right});
    }
    for (auto [l, r] : ans) {
      cout << l << " " << r << endl;
    }
  }
}

abc255f{
  #include <iostream>
  using namespace std;

  int n;
  int P[200005], I[200005], Iinv[200005];
  int L[200005], R[200005];

  bool solve(int s, int t, int S, int T)
  {
    int r = P[s], p = Iinv[r];
    if(p < S || T < p) return false;

    if(p-S > 0){
      L[r] = P[s+1];
      if(!solve(s+1, s+p-S, S, p-1)) return false;
    }
    if(T-p > 0){
      R[r] = P[s+p-S+1];
      if(!solve(s+p-S+1, t, p+1, T)) return false;
    }
    return true;
  }

  int main(void)
  {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> P[i];
    for(int i = 1; i <= n; i++) cin >> I[i];
    for(int i = 1; i <= n; i++) Iinv[I[i]] = i;

    if(P[1] != 1 || !solve(1, n, 1, n)){
      cout << -1 << endl;
      return 0;
    }
    for(int i = 1; i <= n; i++) cout << L[i] << " " << R[i] << endl;

    return 0;
  }

}

abc170d{
  const int MA = 1000001;
  int N, A[201010];
  int cnt[1010101];
  bool ok[1010101];
  //---------------------------------------------------------------------------------------------------
  void _main() {
      cin >> N;
      rep(i, 0, N) cin >> A[i];

      rep(i, 0, N) cnt[A[i]]++;
      rep(x, 1, MA) ok[x] = true;
      rep(x, 1, MA) if(0 < cnt[x]) {
          if (1 < cnt[x]) ok[x] = false;
          for (int x2 = x * 2; x2 < MA; x2 += x) ok[x2] = false;
      }

      int ans = 0;
      rep(i, 0, N) if (ok[A[i]]) ans++;
      cout << ans << endl;
  }
}

abc170e{
  #include<bits/stdc++.h>
  #define rep(i,a,b) for(int i=a;i<b;i++)
  #define rrep(i,a,b) for(int i=a;i>=b;i--)
  #define fore(i,a) for(auto &i:a)
  #define all(x) (x).begin(),(x).end()
  //#pragma GCC optimize ("-O3")
  using namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }
  typedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;
  template<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }
  template<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }
  //---------------------------------------------------------------------------------------------------
  #define def inf
  template<class V, int NV> struct SegTree { //[l,r)
      V comp(V& l, V& r) { return min(l, r); };

      vector<V> val; SegTree() { val = vector<V>(NV * 2, def); }
      V get(int x, int y, int l = 0, int r = NV, int k = 1) {
          if (r <= x || y <= l)return def; if (x <= l && r <= y)return val[k];
          auto a = get(x, y, l, (l + r) / 2, k * 2);
          auto b = get(x, y, (l + r) / 2, r, k * 2 + 1);
          return comp(a, b);
      }
      void update(int i, V v) {
          i += NV; val[i] = v;
          while (i > 1) i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]);
      }
      void add(int i, V v) { update(i, val[i + NV] + v); }
      V operator[](int x) { return get(x, x + 1); }
  };

  int N, Q, A[201010], B[201010];
  SegTree<int, 1 << 18> st;
  multiset<int> rates[201010];
  int cnt[201010];
  //---------------------------------------------------------------------------------------------------
  void add(int child, int to) {
      cnt[to]++;
      rates[to].insert(A[child]);
      st.update(to, *rates[to].rbegin());
  }
  void erase(int child, int from) {
      cnt[from]--;
      auto ite = rates[from].find(A[child]);
      rates[from].erase(ite);

      if (cnt[from] == 0) st.update(from, inf);
      else st.update(from, *rates[from].rbegin());
  }
  //---------------------------------------------------------------------------------------------------
  void _main() {
      cin >> N >> Q;
      rep(i, 1, N + 1) {
          cin >> A[i] >> B[i];
          add(i, B[i]);
      }

      rep(_, 0, Q) {
          int C, D; cin >> C >> D;
          erase(C, B[C]);
          B[C] = D;
          add(C, B[C]);

          int ans = st.get(0, 201010);
          printf("%d\n", ans);
      }
  }

}

algo_logic_segtree{
  /* RMQ：[0,n-1] について、区間ごとの最小値を管理する構造体
    update(i,x): i 番目の要素を x に更新。O(log(n))
    query(a,b): [a,b) での最小の要素を取得。O(log(n))
  */
  template <typename T>
  struct RMQ {
      const T INF = numeric_limits<T>::max();
      int n;         // 葉の数
      vector<T> dat; // 完全二分木の配列
      RMQ(int n_) : n(), dat(n_ * 4, INF) { // 葉の数は 2^x の形
          int x = 1;
          while (n_ > x) {
              x *= 2;
          }
          n = x;
      }
      void update(int i, T x) {
          i += n - 1;
          dat[i] = x;
          while (i > 0) {
              i = (i - 1) / 2;  // parent
              dat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);
          }
      }
      // the minimum element of [a,b)
      T query(int a, int b) { return query_sub(a, b, 0, 0, n); }
      T query_sub(int a, int b, int k, int l, int r) {
          if (r <= a || b <= l) {
              return INF;
          } else if (a <= l && r <= b) {
              return dat[k];
          } else {
              T vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
              T vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
              return min(vl, vr);
          }
      }
  };
}


algo_logic_segtree2{
  /* RMQ：[0,n-1] について、区間ごとの最小値を管理する構造体
    update(a,b,x): 区間[a,b) の要素を x に更新。O(log(n))
    query(a,b): [a,b) での最小の要素を取得。O(log(n))
  */
  template <typename T>
  struct RMQ {
      const T INF = numeric_limits<T>::max();
      int n;
      vector<T> dat, lazy;
      RMQ(int n_) : n(), dat(n_ * 4, INF), lazy(n_ * 4, INF) {
          int x = 1;
          while (n_ > x) x *= 2;
          n = x;
      }

      /* lazy eval */
      void eval(int k) {
          if (lazy[k] == INF) return;  // 更新するものが無ければ終了
          if (k < n - 1) {             // 葉でなければ子に伝搬
              lazy[k * 2 + 1] = lazy[k];
              lazy[k * 2 + 2] = lazy[k];
          }
          // 自身を更新
          dat[k] = lazy[k];
          lazy[k] = INF;
      }

      void update(int a, int b, T x, int k, int l, int r) {
          eval(k);
          if (a <= l && r <= b) {  // 完全に内側の時
              lazy[k] = x;
              eval(k);
          } else if (a < r && l < b) {                     // 一部区間が被る時
              update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子
              update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子
              dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);
          }
      }
      void update(int a, int b, T x) { update(a, b, x, 0, 0, n); }

      T query_sub(int a, int b, int k, int l, int r) {
          eval(k);
          if (r <= a || b <= l) {  // 完全に外側の時
              return INF;
          } else if (a <= l && r <= b) {  // 完全に内側の時
              return dat[k];
          } else {  // 一部区間が被る時
              T vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
              T vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
              return min(vl, vr);
          }
      }
      T query(int a, int b) { return query_sub(a, b, 0, 0, n); }

      /* debug */
      inline T operator[](int a) { return query(a, a + 1); }
      void print() {
          for (int i = 0; i < 2 * n - 1; ++i) {
              cout << (*this)[i];
              if (i != n) cout << ",";
          }
          cout << endl;
      }
  };
}

algo_logic_segtree3{
  /* RMQ：[0,n-1] について、区間ごとの最小値を管理する構造体
    set(int i, T x), build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n)
    update(i,x): i 番目の要素を x に更新。O(log(n))
    query(a,b): [a,b) での最小の要素を取得。O(log(n))
    find_rightest(a,b,x): [a,b) で x以下の要素を持つ最右位置を求める。O(log(n))
    find_leftest(a,b,x): [a,b) で x以下の要素を持つ最左位置を求める。O(log(n))
  */
  template <typename T>
  struct RMQ {
      const T e = numeric_limits<T>::max();
      function<T(T, T)> fx = [](T x1, T x2) -> T { return min(x1, x2); };
      int n;
      vector<T> dat;
      RMQ(int n_) : n(), dat(n_ * 4, e) {
          int x = 1;
          while (n_ > x) {
              x *= 2;
          }
          n = x;
      }

      void set(int i, T x) { dat[i + n - 1] = x; }
      void build() {
          for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);
      }

      void update(int i, T x) {
          i += n - 1;
          dat[i] = x;
          while (i > 0) {
              i = (i - 1) / 2;  // parent
              dat[i] = fx(dat[i * 2 + 1], dat[i * 2 + 2]);
          }
      }

      // the minimum element of [a,b)
      T query(int a, int b) { return query_sub(a, b, 0, 0, n); }
      T query_sub(int a, int b, int k, int l, int r) {
          if (r <= a || b <= l) {
              return e;
          } else if (a <= l && r <= b) {
              return dat[k];
          } else {
              T vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
              T vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
              return fx(vl, vr);
          }
      }

      int find_rightest(int a, int b, T x) { return find_rightest_sub(a, b, x, 0, 0, n); }
      int find_leftest(int a, int b, T x) { return find_leftest_sub(a, b, x, 0, 0, n); }
      int find_rightest_sub(int a, int b, T x, int k, int l, int r) {
          if (dat[k] > x || r <= a || b <= l) {  // 自分の値がxより大きい or [a,b)が[l,r)の範囲外ならreturn a-1
              return a - 1;
          } else if (k >= n - 1) {  // 自分が葉ならその位置をreturn
              return (k - (n - 1));
          } else {
              int vr = find_rightest_sub(a, b, x, 2 * k + 2, (l + r) / 2, r);
              if (vr != a - 1) {  // 右の部分木を見て a-1 以外ならreturn
                  return vr;
              } else {  // 左の部分木を見て値をreturn
                  return find_rightest_sub(a, b, x, 2 * k + 1, l, (l + r) / 2);
              }
          }
      }
      int find_leftest_sub(int a, int b, T x, int k, int l, int r) {
          if (dat[k] > x || r <= a || b <= l) {  // 自分の値がxより大きい or [a,b)が[l,r)の範囲外ならreturn b
              return b;
          } else if (k >= n - 1) {  // 自分が葉ならその位置をreturn
              return (k - (n - 1));
          } else {
              int vl = find_leftest_sub(a, b, x, 2 * k + 1, l, (l + r) / 2);
              if (vl != b) {  // 左の部分木を見て b 以外ならreturn
                  return vl;
              } else {  // 右の部分木を見て値をreturn
                  return find_leftest_sub(a, b, x, 2 * k + 2, (l + r) / 2, r);
              }
          }
      }
  };
}

algo_logic_segtree4{
  /* SegTree<X>(n,fx,ex): モノイド(集合X, 二項演算fx, 単位元ex)についてサイズnで構築
    set(int i, X x), build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n)
    update(i,x): i 番目の要素を x に更新。O(log(n))
    query(a,b): [a,b) 全てにfxを作用させた値を取得。O(log(n))
  */
  template <typename X>
  struct SegTree {
      using FX = function<X(X, X)>; // X•X -> X となる関数の型
      int n;
      FX fx;
      const X ex;
      vector<X> dat;
      SegTree(int n_, FX fx_, X ex_) : n(), fx(fx_), ex(ex_), dat(n_ * 4, ex_) {
          int x = 1;
          while (n_ > x) {
              x *= 2;
          }
          n = x;
      }

      void set(int i, X x) { dat[i + n - 1] = x; }
      void build() {
          for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);
      }

      void update(int i, X x) {
          i += n - 1;
          dat[i] = x;
          while (i > 0) {
              i = (i - 1) / 2;  // parent
              dat[i] = fx(dat[i * 2 + 1], dat[i * 2 + 2]);
          }
      }

      X query(int a, int b) { return query_sub(a, b, 0, 0, n); }
      X query_sub(int a, int b, int k, int l, int r) {
          if (r <= a || b <= l) {
              return ex;
          } else if (a <= l && r <= b) {
              return dat[k];
          } else {
              X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
              X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
              return fx(vl, vr);
          }
      }
  };
}

abc257c{
  #include <bits/stdc++.h>
  using namespace std;

  int main() {
    int n, x, ans;
    string s;
    vector<pair<int, char> >a;
    cin >> n;
    cin >> s;
    ans = 0;
    for (int i = 0; i < n; i++) {
      cin >> x;
      a.push_back({ x,s[i] });
      if (s[i] == '1')ans++;
    }
    sort(a.begin(), a.end());
    x = ans;
    for (int i = 0; i < n; i++) {
      if (a[i].second == '1')x--;
      else x++;
      if (i < (n - 1)) {
        if (a[i].first != a[i + 1].first)ans = max(ans, x);
      }
      else ans = max(ans, x);
    }
    cout << ans << endl;
    return 0;
  }

}

abc257d{
  #include<bits/stdc++.h>
  using namespace std;

  int main(){
    int N;
    cin >> N;
    vector<vector<long long>>data(N);
    for(int i=0;i<N;i++){
      int x,y,p;
      cin >> x >> y >> p;
      data[i]={x,y,p};
    }
    
    vector<vector<long long>>dist(N,vector<long long>(N));
    for(int i=0;i<N;i++)for(int j=0;j<N;j++){
      dist[i][j]=(abs(data[i][0]-data[j][0])+abs(data[i][1]-data[j][1])+data[i][2]-1)/data[i][2];
    }

    for(int k=0;k<N;k++)for(int i=0;i<N;i++)for(int j=0;j<N;j++)dist[i][j]=min(dist[i][j],max(dist[i][k],dist[k][j]));

    long long ans=1e15;
    for(int i=0;i<N;i++){
      long long tans=0;
      for(int j=0;j<N;j++)tans=max(tans,dist[i][j]);
      ans=min(ans,tans);
    }
    cout << ans << endl;
  }

}

abc257e{
  #include <bits/stdc++.h>
  using namespace std;

  using ll = long long;

  int main() {
      int n;
      cin >> n;
      vector<int> c(10);
      for(int i = 1; i <= 9; i++) cin >> c[i];

      int mn = *min_element(c.begin() + 1, c.end());
      int length = n / mn;

      string ans = "";

      for(int i = 0; i < length; i++) {
          for(int j = 9; j >= 1; j--) {
              if((ll)mn * (length - 1 - i) + c[j] <= n) {
                  n -= c[j];
                  ans.push_back((char)('0' + j));
                  break;
              }
          }
      }

      cout << ans << endl;

      return 0;
  }

}

abc257f{
  #include <bits/stdc++.h>
  using namespace std;

  #define rep(i, n) for(int i = 0; i < n; ++i)
  #define N 300010
  #define INF (int)1e+9

  int main(void) {
    int n, m;
    bool ex[N];
    bool used[N];
    rep(i, N)ex[i] = false;
    vector<int>e[N];
    int d[2][N];
    queue<int>q;
    int mn[2];
    int x, y;

    cin >> n >> m;
    for (int i = 0; i < m; i++) {
      cin >> x >> y;
      if (x == 0)ex[y - 1] = true;
      else {
        e[x - 1].push_back(y - 1);
        e[y - 1].push_back(x - 1);
      }
    }

    for (int i = 0; i < n; i++)d[0][i] = INF;
    for (int i = 0; i < n; i++)used[i] = false;
    mn[0] = INF;
    used[0] = true;
    d[0][0] = 0;
    q.push(0);
    while (!q.empty()) {
      x = q.front();
      q.pop();
      if (ex[x])mn[0] = min(mn[0], d[0][x]);
      y = e[x].size();
      for (int i = 0; i < y; i++) {
        if (!used[e[x][i]]) {
          used[e[x][i]] = true;
          d[0][e[x][i]] = d[0][x] + 1;
          q.push(e[x][i]);
        }
      }
    }

    for (int i = 0; i < n; i++)d[1][i] = INF;
    for (int i = 0; i < n; i++)used[i] = false;
    mn[1] = INF;
    used[n - 1] = true;
    d[1][n - 1] = 0;
    q.push(n - 1);
    while (!q.empty()) {
      x = q.front();
      q.pop();
      if (ex[x])mn[1] = min(mn[1], d[1][x]);
      y = e[x].size();
      for (int i = 0; i < y; i++) {
        if (!used[e[x][i]]) {
          used[e[x][i]] = true;
          d[1][e[x][i]] = d[1][x] + 1;
          q.push(e[x][i]);
        }
      }
    }

    for (int i = 0; i < n; i++) {
      x = min(d[0][n - 1], mn[0] + mn[1] + 2);
      x = min(x, mn[0] + 1 + d[1][i]);
      x = min(x, mn[1] + 1 + d[0][i]);
      if (x < INF)cout << x;
      else cout << -1;
      if (i < (n - 1))cout << " ";
      else cout << endl;
    }

    return 0;
  }

}

abc252g1{
  #include <bits/stdc++.h>
  using namespace std;

  #define MOD 998244353

  int main() {
    int n;
    int a[501];
    long long dp[501][501][2];

    cin >> n;
    for (int i = 0; i < n; i++)cin >> a[i];
    a[n + 1] = n + 1;

    for (int r = 0; r < n; r++) {
      for (int i = 0; i < 2; i++)dp[r][r][i] = 1LL;
      for (int l = r - 1; l >= 0; l--) {
        for (int i = 0; i < 2; i++)dp[l][r][i] = 0LL;
        for (int k = l; k < r; k++) {
          dp[l][r][0] = (dp[l][r][0] + (dp[l][k][1] * dp[k + 1][r][0])) % MOD;
          if (a[k + 1] < a[r + 1])dp[l][r][1] = (dp[l][r][1] + (dp[l][k][1] * dp[k + 1][r][0])) % MOD;
        }
      }
    }

    cout << dp[0][n - 1][0] << endl;
    return 0;
  }

}
abc252g2{
  #include <bits/stdc++.h>
  using namespace std;

  #define MOD 998244353

  int main() {
    int n;
    int a[500];
    long long dp[501][501];

    cin >> n;
    for (int i = 0; i < n; i++)cin >> a[i];

    for (int l = n; l >= 1; l--) {
      dp[l][l] = 1;
      for (int r = l + 1; r <= n; r++) {
        dp[l][r] = dp[l + 1][r];
        for (int k = l + 1; k < r; k++) {
          if (a[l] < a[k])dp[l][r] = (dp[l][r] + (dp[l + 1][k] * dp[k][r])) % MOD;
        }
      }
    }

    cout << dp[1][n] << endl;
    return 0;
  }

}

arc143{
  #include <iostream>
  #include <algorithm>
  #include <bitset>
  #include <cmath>
  #include <functional>
  #include <iomanip>
  #include <map>
  #include <numeric>
  #include <queue>
  #include <random>
  #include <regex>
  #include <set>
  #include <sstream>
  #include <stack>
  #include <string>
  #include <unordered_set>
  #include <vector>
  using namespace std;

  #include <atcoder/all>
  using namespace atcoder;
  //using mint = modint;
  //using mint = modint1000000007;
  using mint = modint998244353;

  struct comb {
    vector<mint> F, IF;
    comb(int size) {
      F.resize(size);
      IF.resize(size);
      F[0] = 1, IF[0] = 1;
      for (int i = 1; i < size; i++) {
        F[i] = F[i - 1] * i;
        IF[i] = F[i].inv();
      }
    }
    mint c(int a, int b) {
      if (a < b || b < 0) return 0;
      return F[a] * IF[b] * IF[a - b];
    }
  };
  int main() {
    int N;
    cin >> N;
    comb c(N * N + 1);
    mint ans = c.F[N * N] - N * N * c.c(N * N, N + N - 1) * c.F[N - 1] * c.F[N - 1] * c.F[N * N - N - N + 1];
    cout << ans.val() << endl;

  }
}

abc299c{
  int main() {
    string s;
    cin >> s;
    string t;
    cin >> t;
    using Q = queue<pair<char, int>>;
    Q s_runlength = makeRunLength(s);
    Q t_runlength = makeRunLength(t);

    int n = t.size();
    bool flg = true;
    while (!s_runlength.empty() && !t_runlength.empty()) {
      auto [c1, len1] = s_runlength.front();
      auto [c2, len2] = t_runlength.front();
      s_runlength.pop();
      t_runlength.pop();
      if (c1 != c2) {
        flg = false;
        break;
      } else {
        if (len1 > len2 || (len1 == 1 && len2 >= 2)) {
          flg = false;
          break;
        }
      }
    }
    if (!s_runlength.empty() || !t_runlength.empty()) { flg = false; }

    yes_no(flg);
  }
}

abc299b{
  int main() {
    
    double a,b,d;
    cin>>a>>b>>d;
    double r = hypot(a,b);
    double theta = atan2(b,a);
    theta += d * acos(-1.0) / 180.0;
    double x = cos(theta) * r;
    double y = sin(theta) * r;
    cout<<fixed<<setprecision(10)<<x<<' '<<y<<endl;
    return 0;
    
  }
}

abc299d{
  int main() {
    int n;
    cin >> n;
    long double sx, sy, tx, ty;
    cin >> sx >> sy >> tx >> ty;

    Point p1(sx, sy);
    Point p2(tx, ty);
    vector<Circle> circles;
    dsu uf(n);
    int p1_group = -1;
    int p2_group = -1;
    for (int i = 0; i < n; i++) {
      long double x, y, r;
      cin >> x >> y >> r;
      circles.push_back(Circle(Point(x, y), r));
    }
    for (int i = 0; i < n; i++) {
      Circle c1 = circles[i];

      if (p1_group < 0 && c1.isOnCircle(p1)) p1_group = i;
      if (p2_group < 0 && c1.isOnCircle(p2)) p2_group = i;
      for (int j = i + 1; j < n; j++) {
        Circle c2 = circles[j];

        if (c1.isHasShare(c2)) uf.merge(i, j);
      }
    }
    yes_no(uf.same(p1_group, p2_group));
  }
}

abc259e{
  int main(void)
  {
    ios::sync_with_stdio(0);
    cin.tie(0);
  
    cin >> n;
    ll m, p, e;
    rep(i, 1, n){
      cin >> m;
      rep(j, 1, m){
        cin >> p >> e;
        vec[i].pb(P(p, e));
        if(mp[p].fi < e) mp[p] = P(e, 1);
        else if(mp[p].fi == e) mp[p].se++;
      }
    }
  
    ll ans = 1;
    rep(i, 1, n){
      for(auto p : vec[i]){
        if(mp[p.fi].se == 1 && p.se == mp[p.fi].fi){
          ans++;
          break;
        }
      }
    }
    chmin(ans, n);
    outl(ans);
  
    return 0;
  }
}

abc259e2{
  #include<bits/stdc++.h>
  using namespace std;
  #define rep(i,l,r)for(int i=(l);i<(r);i++)

  int main(){
    int n;
    cin >> n;
    vector<vector<pair<int,int>>>a;
    map<int,pair<int,int>>eM;
    rep(i,0,n){
      vector<pair<int,int>>pe;
      int m;
      cin >> m;
      rep(_,0,m){
        int p,e;
        cin >> p >> e;
        pe.push_back({p,e});
        if(eM[p].first<e)eM[p]={e,1};
        else if(eM[p].first==e)eM[p].second++;
      }
      a.push_back(pe);
    }

    //あるpで、唯一の最大が消えたらlcmが変わる
    int flag=false;//消してもlcmが変わらないものがあるか
    int ans=0;
    rep(i,0,n){
      int uni=false;
      for(auto[p,e]:a[i])if(eM[p]==make_pair(e,1))uni=true;
      if(uni)ans++;
      else flag=true;
    }
    if(flag)ans++;
    cout << ans << endl;
  }
}
abc259f{
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;
  typedef long long ll;
  typedef pair<int, ll> E;
  const ll inf = 1e18;

  int n;
  int d[300005];
  vector<E> G[300005];
  ll dp[300005][2];

  void dfs(int v, int p)
  {
    vector<ll> vec;
    for(auto e : G[v]){
      int u = e.first, w = e.second;
      if(u == p) continue;
      dfs(u, v);
      vec.push_back(dp[u][0]+w-dp[u][1]);
      dp[v][0] += dp[u][1], dp[v][1] += dp[u][1];
    }
    sort(vec.rbegin(), vec.rend());
    
    for(int i = 0; i < (int)vec.size(); i++){
      if(vec[i] <= 0) break;
      if(i < d[v]-1) dp[v][0] += vec[i];
      if(i < d[v]) dp[v][1] += vec[i];
    }
    if(d[v] == 0) dp[v][0] = -inf;
  }

  int main(void)
  {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> d[i];
    int u, v, w;
    for(int i = 1; i <= n-1; i++){
      cin >> u >> v >> w;
      G[u].push_back(E(v, w));
      G[v].push_back(E(u, w));
    }
    dfs(1, -1);
    cout << dp[1][1] << endl;
      
    return 0;
  }

}

abc261d{
  #include <bits/stdc++.h>
  using namespace std;

  int main(void) {
    int n, m;
    long long x[5001];
    long long c, y;
    long long b[5001], dp[5001][5001];
    long long ans;
    for (int i = 0; i <= n; i++)b[i] = 0;

    cin >> n >> m;
    for (int i = 0; i < n; i++)cin >> x[i + 1];
    for (int i = 0; i < m; i++) {
      cin >> c >> y;
      b[c] = y;
    }

    dp[0][0] = 0;
    for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= i; j++) dp[i][j] = dp[i - 1][j - 1] + x[i] + b[j];

      dp[i][0] = 0;
      for (int j = 0; j < i; j++)dp[i][0] = max(dp[i][0], dp[i - 1][j]);
    }

    ans = 0;
    for (int i = 0; i <= n; i++)ans = max(ans, dp[n][i]);
    cout << ans << endl;

    return 0;
  }

}

abc261e{
  #include<bits/stdc++.h>
  using namespace std;
  #define bit(x,i)(((x)>>(i))&1)

  int main(){
    int n,c;
    cin >> n >> c;
    vector<pair<int,int>>op(n);
    for(int i=0;i<n;i++)cin >> op[i].first >> op[i].second;

    vector<int>ans(n);
    for(int k=0;k<30;k++){
      array<int,2>func={0,1};
      int crr=bit(c,k);
      for(int i=0;i<n;i++){
        array<int,2>f;
        int x=bit(op[i].second,k);
        if(op[i].first==1)f={0&x,1&x};
        if(op[i].first==2)f={0|x,1|x};
        if(op[i].first==3)f={0^x,1^x};
        func={f[func[0]],f[func[1]]};
        crr=func[crr];
        ans[i]|=crr<<k;
      }
    }

    for(int i=0;i<n;i++)cout << ans[i] << endl;
  }

}

abc261f{
  #include <bits/stdc++.h>
  #include <atcoder/all>
  using namespace std;
  using namespace atcoder;

  int main() {
    int n, x, sz;
    int c[300000];
    vector<int>a[300001];
    long long ans = 0;

    cin >> n;
    for (int i = 0; i < n; i++)cin >> c[i];
    for (int i = 0; i < n; i++) {
      cin >> x;
      a[0].push_back(x - 1);
      a[c[i]].push_back(x - 1);
    }

    fenwick_tree<long long> fw(n);
    for (int i = 0; i <= n; i++) {
      sz = a[i].size();
      for (int j = 0; j < sz; j++) {
        if (i == 0)ans += fw.sum(a[i][j] + 1, n);
        else ans -= fw.sum(a[i][j] + 1, n);
        fw.add(a[i][j], 1LL);
      }
      for (int j = 0; j < sz; j++)fw.add(a[i][j], -1LL);
    }

    cout << ans << endl;
    return 0;
  }

}

abc260b{
  #include<bits/stdc++.h>

  using namespace std;

  int main(){
    int n,x,y,z;
    cin >> n >> x >> y >> z;
    vector<int> a(n+5),b(n+5);
    for(int i=1;i<=n;i++){cin >> a[i];}
    for(int i=1;i<=n;i++){cin >> b[i];}
    vector<bool> passed(n+5,false);

    vector<int> c;
    for(int i=1;i<=n;i++){
      c.push_back(10000*(100-a[i])+i);
    }
    sort(c.begin(),c.end());
    for(int i=0;i<x;i++){
      passed[c[i]%10000]=true;
    }

    c.clear();
    for(int i=1;i<=n;i++){
      if(!passed[i]){
        c.push_back(10000*(100-b[i])+i);
      }
    }
    sort(c.begin(),c.end());
    for(int i=0;i<y;i++){
      passed[c[i]%10000]=true;
    }

    c.clear();
    for(int i=1;i<=n;i++){
      if(!passed[i]){
        c.push_back(10000*(200-(a[i]+b[i]))+i);
      }
    }
    sort(c.begin(),c.end());
    for(int i=0;i<z;i++){
      passed[c[i]%10000]=true;
    }

    for(int i=1;i<=n;i++){
      if(passed[i]){cout << i << "\n";}
    }
    return 0;
  }

}

abc260d{
  #include<bits/stdc++.h>

  using namespace std;

  int main(){
    int n,k;
    cin >> n >> k;
    vector<int> under(n+5,-1);
    vector<int> pile(n+5,0);
    set<int> st;
    vector<int> res(n+5,-1);
    for(int i=1;i<=n;i++){
      int p;
      cin >> p;
      auto it=st.upper_bound(p);
      if(it==st.end()){
        pile[p]=1;
        st.insert(p);
      }
      else{
        under[p]=(*it);
        pile[p]=pile[(*it)]+1;
        st.erase(it);
        st.insert(p);
      }
      
      if(pile[p]==k){
        st.erase(p);
        int x=p;
        for(int j=0;j<k;j++){
          res[x]=i;
          x=under[x];
        }
      }
    }

    for(int i=1;i<=n;i++){cout << res[i] << "\n";}
    return 0;
  }

}

abc260e{
  #include <iostream>
  #include <vector>
  using namespace std;

  int main() {
    int N, M;
    cin >> N >> M;
    vector<int> A(N), B(N);
    for (int i = 0; i < N; i++) cin >> A[i] >> B[i];
    vector<vector<int>> inv(M + 1);
    for (int i = 0; i < N; i++) {
      inv[A[i]].push_back(i);
      inv[B[i]].push_back(i);
    }
    vector<int> cnt(N), ans(M + 3);
    int cnt_zero = N;
    for (int i = 1, j = 1; i <= M;) {
      while (j <= M and cnt_zero != 0) {
        for (auto& x : inv[j]) {
          if (cnt[x] == 0) cnt_zero--;
          cnt[x]++;
        }
        j++;
      }
      if (cnt_zero != 0) break;
      ans[j - i]++, ans[M + 1 - i + 1]--;
      for (auto& x : inv[i]) {
        cnt[x]--;
        if (cnt[x] == 0) cnt_zero++;
      }
      i++;
    }
    for (int i = 1; i <= M; i++) {
      ans[i] += ans[i - 1];
      cout << ans[i] << " \n"[i == M];
    }
  }

}

abc260f{
  #include <iostream>
  #include <vector>
  using namespace std;

  int main() {
    int S, T, M;
    cin >> S >> T >> M;
    vector G(S, vector<int>{});
    for (int i = 0, u, v; i < M; i++) {
      cin >> u >> v;
      G[u - 1].push_back(v - S - 1);
    }
    vector dp(T, vector(T, -1));
    for (int i = 0; i < S; i++) {
      for (auto& u : G[i]) {
        for (auto& v : G[i]) {
          if (u == v) continue;
          if (dp[u][v] != -1) {
            cout << i + 1 << " " << dp[u][v] + 1 << " ";
            cout << u + S + 1 << " " << v + S + 1 << endl;
            exit(0);
          }
          dp[u][v] = i;
        }
      }
    }
    cout << "-1" << endl;
  }

}

abc260Ex{
  /**
 *  date : 2022-07-09 20:08:48
 */

  #define NDEBUG
  using namespace std;

  // intrinstic
  #include <immintrin.h>

  #include <algorithm>
  #include <array>
  #include <bitset>
  #include <cassert>
  #include <cctype>
  #include <cfenv>
  #include <cfloat>
  #include <chrono>
  #include <cinttypes>
  #include <climits>
  #include <cmath>
  #include <complex>
  #include <cstdarg>
  #include <cstddef>
  #include <cstdint>
  #include <cstdio>
  #include <cstdlib>
  #include <cstring>
  #include <deque>
  #include <fstream>
  #include <functional>
  #include <initializer_list>
  #include <iomanip>
  #include <ios>
  #include <iostream>
  #include <istream>
  #include <iterator>
  #include <limits>
  #include <list>
  #include <map>
  #include <memory>
  #include <new>
  #include <numeric>
  #include <ostream>
  #include <queue>
  #include <random>
  #include <set>
  #include <sstream>
  #include <stack>
  #include <streambuf>
  #include <string>
  #include <tuple>
  #include <type_traits>
  #include <typeinfo>
  #include <unordered_map>
  #include <unordered_set>
  #include <utility>
  #include <vector>

  // utility
  namespace Nyaan {
  using ll = long long;
  using i64 = long long;
  using u64 = unsigned long long;
  using i128 = __int128_t;
  using u128 = __uint128_t;

  template <typename T>
  using V = vector<T>;
  template <typename T>
  using VV = vector<vector<T>>;
  using vi = vector<int>;
  using vl = vector<long long>;
  using vd = V<double>;
  using vs = V<string>;
  using vvi = vector<vector<int>>;
  using vvl = vector<vector<long long>>;

  template <typename T, typename U>
  struct P : pair<T, U> {
    template <typename... Args>
    P(Args... args) : pair<T, U>(args...) {}

    using pair<T, U>::first;
    using pair<T, U>::second;

    P &operator+=(const P &r) {
      first += r.first;
      second += r.second;
      return *this;
    }
    P &operator-=(const P &r) {
      first -= r.first;
      second -= r.second;
      return *this;
    }
    P &operator*=(const P &r) {
      first *= r.first;
      second *= r.second;
      return *this;
    }
    template <typename S>
    P &operator*=(const S &r) {
      first *= r, second *= r;
      return *this;
    }
    P operator+(const P &r) const { return P(*this) += r; }
    P operator-(const P &r) const { return P(*this) -= r; }
    P operator*(const P &r) const { return P(*this) *= r; }
    template <typename S>
    P operator*(const S &r) const {
      return P(*this) *= r;
    }
    P operator-() const { return P{-first, -second}; }
  };

  using pl = P<ll, ll>;
  using pi = P<int, int>;
  using vp = V<pl>;

  constexpr int inf = 1001001001;
  constexpr long long infLL = 4004004004004004004LL;

  template <typename T>
  int sz(const T &t) {
    return t.size();
  }

  template <typename T, typename U>
  inline bool amin(T &x, U y) {
    return (y < x) ? (x = y, true) : false;
  }
  template <typename T, typename U>
  inline bool amax(T &x, U y) {
    return (x < y) ? (x = y, true) : false;
  }

  template <typename T>
  inline T Max(const vector<T> &v) {
    return *max_element(begin(v), end(v));
  }
  template <typename T>
  inline T Min(const vector<T> &v) {
    return *min_element(begin(v), end(v));
  }
  template <typename T>
  inline long long Sum(const vector<T> &v) {
    return accumulate(begin(v), end(v), 0LL);
  }

  template <typename T>
  int lb(const vector<T> &v, const T &a) {
    return lower_bound(begin(v), end(v), a) - begin(v);
  }
  template <typename T>
  int ub(const vector<T> &v, const T &a) {
    return upper_bound(begin(v), end(v), a) - begin(v);
  }

  constexpr long long TEN(int n) {
    long long ret = 1, x = 10;
    for (; n; x *= x, n >>= 1) ret *= (n & 1 ? x : 1);
    return ret;
  }

  template <typename T, typename U>
  pair<T, U> mkp(const T &t, const U &u) {
    return make_pair(t, u);
  }

  template <typename T>
  vector<T> mkrui(const vector<T> &v, bool rev = false) {
    vector<T> ret(v.size() + 1);
    if (rev) {
      for (int i = int(v.size()) - 1; i >= 0; i--) ret[i] = v[i] + ret[i + 1];
    } else {
      for (int i = 0; i < int(v.size()); i++) ret[i + 1] = ret[i] + v[i];
    }
    return ret;
  };

  template <typename T>
  vector<T> mkuni(const vector<T> &v) {
    vector<T> ret(v);
    sort(ret.begin(), ret.end());
    ret.erase(unique(ret.begin(), ret.end()), ret.end());
    return ret;
  }

  template <typename F>
  vector<int> mkord(int N, F f) {
    vector<int> ord(N);
    iota(begin(ord), end(ord), 0);
    sort(begin(ord), end(ord), f);
    return ord;
  }

  template <typename T>
  vector<int> mkinv(vector<T> &v) {
    int max_val = *max_element(begin(v), end(v));
    vector<int> inv(max_val + 1, -1);
    for (int i = 0; i < (int)v.size(); i++) inv[v[i]] = i;
    return inv;
  }

  vector<int> mkiota(int n) {
    vector<int> ret(n);
    iota(begin(ret), end(ret), 0);
    return ret;
  }

  template <typename T>
  T mkrev(const T &v) {
    T w{v};
    reverse(begin(w), end(w));
    return w;
  }

  template <typename T>
  bool nxp(vector<T> &v) {
    return next_permutation(begin(v), end(v));
  }

  #define inV(T, v, n) \
    vector<T> v(n);    \
    in(v)

  #define inVV(T, v, h, w)                \
    vector<vector<T>> v(h, vector<T>(w)); \
    in(v);

  template <typename T>
  using minpq = priority_queue<T, vector<T>, greater<T>>;

  // 区間：半開区間 (ng, ok] または [ok, ng)
  template <typename T, typename F>
  T binary_search(T ng, T ok, const F &f) {
    if constexpr (is_integral<T>::value == true) {
      while (abs(ok - ng) > 1) {
        T x = (ok + ng) / 2;
        (f(x) ? ok : ng) = x;
      }
      return ok;
    } else {
      for (int iter = 0; iter < 60; iter++) {
        T x = (ok + ng) / 2;
        (f(x) ? ok : ng) = x;
      }
      return ok;
    }
  }

  // 解区間 (l, r)
  template <typename T, typename F>
  void ternary_search(T l, T r, const F &f, bool greater = false) {
    if constexpr (is_integral<T>::value == true) {
      while (abs(l - r) > 2) {
        T llr = (l * 2 + r * 1) / 3;
        T lrr = (l * 1 + r * 2) / 3;
        bool flag = f(llr) < f(lrr);
        if (flag != greater) {
          r = lrr;
        } else {
          l = llr;
        }
      }
      return (l + r) / 2;
    } else {
      for (int iter = 0; iter < 80; iter++) {
        T llr = (l * 2 + r * 1) / 3;
        T lrr = (l * 1 + r * 2) / 3;
        bool flag = f(llr) < f(lrr);
        if (flag != greater) {
          r = lrr;
        } else {
          l = llr;
        }
      }
      return (l + r) / 2;
    }
  }

  }  // namespace Nyaan

  // bit operation
  namespace Nyaan {
  __attribute__((target("popcnt"))) inline int popcnt(const u64 &a) {
    return _mm_popcnt_u64(a);
  }
  inline int lsb(const u64 &a) { return a ? __builtin_ctzll(a) : 64; }
  inline int ctz(const u64 &a) { return a ? __builtin_ctzll(a) : 64; }
  inline int msb(const u64 &a) { return a ? 63 - __builtin_clzll(a) : -1; }
  template <typename T>
  inline int gbit(const T &a, int i) {
    return (a >> i) & 1;
  }
  template <typename T>
  inline void sbit(T &a, int i, bool b) {
    if (gbit(a, i) != b) a ^= T(1) << i;
  }
  constexpr long long PW(int n) { return 1LL << n; }
  constexpr long long MSK(int n) { return (1LL << n) - 1; }
  }  // namespace Nyaan

  // inout
  namespace Nyaan {

  template <typename T, typename U>
  ostream &operator<<(ostream &os, const pair<T, U> &p) {
    os << p.first << " " << p.second;
    return os;
  }
  template <typename T, typename U>
  istream &operator>>(istream &is, pair<T, U> &p) {
    is >> p.first >> p.second;
    return is;
  }

  template <typename T>
  ostream &operator<<(ostream &os, const vector<T> &v) {
    int s = (int)v.size();
    for (int i = 0; i < s; i++) os << (i ? " " : "") << v[i];
    return os;
  }
  template <typename T>
  istream &operator>>(istream &is, vector<T> &v) {
    for (auto &x : v) is >> x;
    return is;
  }

  istream &operator>>(istream &is, __int128_t &x) {
    string S;
    is >> S;
    x = 0;
    int flag = 0;
    for (auto &c : S) {
      if (c == '-') {
        flag = true;
        continue;
      }
      x *= 10;
      x += c - '0';
    }
    if (flag) x = -x;
    return is;
  }

  istream &operator>>(istream &is, __uint128_t &x) {
    string S;
    is >> S;
    x = 0;
    for (auto &c : S) {
      x *= 10;
      x += c - '0';
    }
    return is;
  }

  ostream &operator<<(ostream &os, __int128_t x) {
    if (x == 0) return os << 0;
    if (x < 0) os << '-', x = -x;
    string S;
    while (x) S.push_back('0' + x % 10), x /= 10;
    reverse(begin(S), end(S));
    return os << S;
  }
  ostream &operator<<(ostream &os, __uint128_t x) {
    if (x == 0) return os << 0;
    string S;
    while (x) S.push_back('0' + x % 10), x /= 10;
    reverse(begin(S), end(S));
    return os << S;
  }

  void in() {}
  template <typename T, class... U>
  void in(T &t, U &...u) {
    cin >> t;
    in(u...);
  }

  void out() { cout << "\n"; }
  template <typename T, class... U, char sep = ' '>
  void out(const T &t, const U &...u) {
    cout << t;
    if (sizeof...(u)) cout << sep;
    out(u...);
  }

  void outr() {}
  template <typename T, class... U, char sep = ' '>
  void outr(const T &t, const U &...u) {
    cout << t;
    outr(u...);
  }

  struct IoSetupNya {
    IoSetupNya() {
      cin.tie(nullptr);
      ios::sync_with_stdio(false);
      cout << fixed << setprecision(15);
      cerr << fixed << setprecision(7);
    }
  } iosetupnya;

  }  // namespace Nyaan

  // debug
  namespace DebugImpl {

  template <typename U, typename = void>
  struct is_specialize : false_type {};
  template <typename U>
  struct is_specialize<
      U, typename conditional<false, typename U::iterator, void>::type>
      : true_type {};
  template <typename U>
  struct is_specialize<
      U, typename conditional<false, decltype(U::first), void>::type>
      : true_type {};
  template <typename U>
  struct is_specialize<U, enable_if_t<is_integral<U>::value, void>> : true_type {
  };

  void dump(const char &t) { cerr << t; }

  void dump(const string &t) { cerr << t; }

  void dump(const bool &t) { cerr << (t ? "true" : "false"); }

  void dump(__int128_t t) {
    if (t == 0) cerr << 0;
    if (t < 0) cerr << '-', t = -t;
    string S;
    while (t) S.push_back('0' + t % 10), t /= 10;
    reverse(begin(S), end(S));
    cerr << S;
  }

  void dump(__uint128_t t) {
    if (t == 0) cerr << 0;
    string S;
    while (t) S.push_back('0' + t % 10), t /= 10;
    reverse(begin(S), end(S));
    cerr << S;
  }

  template <typename U,
            enable_if_t<!is_specialize<U>::value, nullptr_t> = nullptr>
  void dump(const U &t) {
    cerr << t;
  }

  template <typename T>
  void dump(const T &t, enable_if_t<is_integral<T>::value> * = nullptr) {
    string res;
    if (t == Nyaan::inf) res = "inf";
    if constexpr (is_signed<T>::value) {
      if (t == -Nyaan::inf) res = "-inf";
    }
    if constexpr (sizeof(T) == 8) {
      if (t == Nyaan::infLL) res = "inf";
      if constexpr (is_signed<T>::value) {
        if (t == -Nyaan::infLL) res = "-inf";
      }
    }
    if (res.empty()) res = to_string(t);
    cerr << res;
  }

  template <typename T, typename U>
  void dump(const pair<T, U> &);
  template <typename T>
  void dump(const pair<T *, int> &);

  template <typename T>
  void dump(const T &t,
            enable_if_t<!is_void<typename T::iterator>::value> * = nullptr) {
    cerr << "[ ";
    for (auto it = t.begin(); it != t.end();) {
      dump(*it);
      cerr << (++it == t.end() ? "" : ", ");
    }
    cerr << " ]";
  }

  template <typename T, typename U>
  void dump(const pair<T, U> &t) {
    cerr << "( ";
    dump(t.first);
    cerr << ", ";
    dump(t.second);
    cerr << " )";
  }

  template <typename T>
  void dump(const pair<T *, int> &t) {
    cerr << "[ ";
    for (int i = 0; i < t.second; i++) {
      dump(t.first[i]);
      cerr << (i == t.second - 1 ? "" : ", ");
    }
    cerr << " ]";
  }

  void trace() { cerr << endl; }
  template <typename Head, typename... Tail>
  void trace(Head &&head, Tail &&...tail) {
    cerr << " ";
    dump(head);
    if (sizeof...(tail) != 0) cerr << ",";
    trace(forward<Tail>(tail)...);
  }

  }  // namespace DebugImpl

  #ifdef NyaanDebug
  #define trc(...)                            \
    do {                                      \
      cerr << "## " << #__VA_ARGS__ << " = "; \
      DebugImpl::trace(__VA_ARGS__);          \
    } while (0)
  #else
  #define trc(...) (void(0))
  #endif

  // macro
  #define each(x, v) for (auto &&x : v)
  #define each2(x, y, v) for (auto &&[x, y] : v)
  #define all(v) (v).begin(), (v).end()
  #define rep(i, N) for (long long i = 0; i < (long long)(N); i++)
  #define repr(i, N) for (long long i = (long long)(N)-1; i >= 0; i--)
  #define rep1(i, N) for (long long i = 1; i <= (long long)(N); i++)
  #define repr1(i, N) for (long long i = (N); (long long)(i) > 0; i--)
  #define reg(i, a, b) for (long long i = (a); i < (b); i++)
  #define regr(i, a, b) for (long long i = (b)-1; i >= (a); i--)
  #define fi first
  #define se second
  #define ini(...)   \
    int __VA_ARGS__; \
    in(__VA_ARGS__)
  #define inl(...)         \
    long long __VA_ARGS__; \
    in(__VA_ARGS__)
  #define ins(...)      \
    string __VA_ARGS__; \
    in(__VA_ARGS__)
  #define in2(s, t)                           \
    for (int i = 0; i < (int)s.size(); i++) { \
      in(s[i], t[i]);                         \
    }
  #define in3(s, t, u)                        \
    for (int i = 0; i < (int)s.size(); i++) { \
      in(s[i], t[i], u[i]);                   \
    }
  #define in4(s, t, u, v)                     \
    for (int i = 0; i < (int)s.size(); i++) { \
      in(s[i], t[i], u[i], v[i]);             \
    }
  #define die(...)             \
    do {                       \
      Nyaan::out(__VA_ARGS__); \
      return;                  \
    } while (0)

  namespace Nyaan {
  void solve();
  }
  int main() { Nyaan::solve(); }

  //

  template <typename fps>
  struct fps_fraction {
    using frac = fps_fraction;
    using mint = typename fps::value_type;

    fps p, q;
    fps_fraction(const fps &numerator = fps{0}, const fps &denominator = fps{1})
        : p(numerator), q(denominator) {}

    friend frac operator+(const frac &l, const frac &r) {
      return frac{l.p * r.q + r.p * l.q, l.q * r.q};
    }
    friend frac operator-(const frac &l, const frac &r) {
      return frac{l.p * r.q - r.p * l.q, l.q * r.q};
    }
    friend frac operator*(const frac &l, const frac &r) {
      return frac{l.p * r.p, l.q * r.q};
    }
    friend frac operator/(const frac &l, const frac &r) {
      return frac{l.p * r.q, l.q * r.p};
    }

    frac &operator+=(const mint &r) {
      (*this).p += (*this).q * r;
      return *this;
    }
    frac &operator-=(const mint &r) {
      (*this).p -= (*this).q * r;
      return *this;
    }
    frac &operator*=(const mint &r) {
      (*this).p *= r;
      return *this;
    }

    frac operator+(const mint &r) { return frac{*this} += r; }
    frac operator-(const mint &r) { return frac{*this} -= r; }
    frac operator*(const mint &r) { return frac{*this} *= r; }
    frac operator/(const mint &r) { return frac{*this} /= r; }
    frac &operator+=(const frac &r) { return *this = (*this) + r; }
    frac &operator-=(const frac &r) { return *this = (*this) - r; }
    frac &operator*=(const frac &r) { return *this = (*this) * r; }
    frac operator-() const { return frac{-p, q}; }
    frac inverse() const { return frac{q, p}; };

    void shrink() { p.shrink(), q.shrink(); }
    friend bool operator==(const frac &l, const frac &r) {
      return l.p == r.p && l.q == r.q;
    }
    friend bool operator!=(const frac &l, const frac &r) {
      return l.p != r.p || l.q != r.q;
    }
    friend ostream &operator<<(ostream &os, const frac &r) {
      os << "[ " << r.p << ", " << r.q << " ]";
      return os;
    }
  };

  template <typename mint>
  struct NTT {
    static constexpr uint32_t get_pr() {
      uint32_t _mod = mint::get_mod();
      using u64 = uint64_t;
      u64 ds[32] = {};
      int idx = 0;
      u64 m = _mod - 1;
      for (u64 i = 2; i * i <= m; ++i) {
        if (m % i == 0) {
          ds[idx++] = i;
          while (m % i == 0) m /= i;
        }
      }
      if (m != 1) ds[idx++] = m;

      uint32_t _pr = 2;
      while (1) {
        int flg = 1;
        for (int i = 0; i < idx; ++i) {
          u64 a = _pr, b = (_mod - 1) / ds[i], r = 1;
          while (b) {
            if (b & 1) r = r * a % _mod;
            a = a * a % _mod;
            b >>= 1;
          }
          if (r == 1) {
            flg = 0;
            break;
          }
        }
        if (flg == 1) break;
        ++_pr;
      }
      return _pr;
    };

    static constexpr uint32_t mod = mint::get_mod();
    static constexpr uint32_t pr = get_pr();
    static constexpr int level = __builtin_ctzll(mod - 1);
    mint dw[level], dy[level];

    void setwy(int k) {
      mint w[level], y[level];
      w[k - 1] = mint(pr).pow((mod - 1) / (1 << k));
      y[k - 1] = w[k - 1].inverse();
      for (int i = k - 2; i > 0; --i)
        w[i] = w[i + 1] * w[i + 1], y[i] = y[i + 1] * y[i + 1];
      dw[1] = w[1], dy[1] = y[1], dw[2] = w[2], dy[2] = y[2];
      for (int i = 3; i < k; ++i) {
        dw[i] = dw[i - 1] * y[i - 2] * w[i];
        dy[i] = dy[i - 1] * w[i - 2] * y[i];
      }
    }

    NTT() { setwy(level); }

    void fft4(vector<mint> &a, int k) {
      if ((int)a.size() <= 1) return;
      if (k == 1) {
        mint a1 = a[1];
        a[1] = a[0] - a[1];
        a[0] = a[0] + a1;
        return;
      }
      if (k & 1) {
        int v = 1 << (k - 1);
        for (int j = 0; j < v; ++j) {
          mint ajv = a[j + v];
          a[j + v] = a[j] - ajv;
          a[j] += ajv;
        }
      }
      int u = 1 << (2 + (k & 1));
      int v = 1 << (k - 2 - (k & 1));
      mint one = mint(1);
      mint imag = dw[1];
      while (v) {
        // jh = 0
        {
          int j0 = 0;
          int j1 = v;
          int j2 = j1 + v;
          int j3 = j2 + v;
          for (; j0 < v; ++j0, ++j1, ++j2, ++j3) {
            mint t0 = a[j0], t1 = a[j1], t2 = a[j2], t3 = a[j3];
            mint t0p2 = t0 + t2, t1p3 = t1 + t3;
            mint t0m2 = t0 - t2, t1m3 = (t1 - t3) * imag;
            a[j0] = t0p2 + t1p3, a[j1] = t0p2 - t1p3;
            a[j2] = t0m2 + t1m3, a[j3] = t0m2 - t1m3;
          }
        }
        // jh >= 1
        mint ww = one, xx = one * dw[2], wx = one;
        for (int jh = 4; jh < u;) {
          ww = xx * xx, wx = ww * xx;
          int j0 = jh * v;
          int je = j0 + v;
          int j2 = je + v;
          for (; j0 < je; ++j0, ++j2) {
            mint t0 = a[j0], t1 = a[j0 + v] * xx, t2 = a[j2] * ww,
                t3 = a[j2 + v] * wx;
            mint t0p2 = t0 + t2, t1p3 = t1 + t3;
            mint t0m2 = t0 - t2, t1m3 = (t1 - t3) * imag;
            a[j0] = t0p2 + t1p3, a[j0 + v] = t0p2 - t1p3;
            a[j2] = t0m2 + t1m3, a[j2 + v] = t0m2 - t1m3;
          }
          xx *= dw[__builtin_ctzll((jh += 4))];
        }
        u <<= 2;
        v >>= 2;
      }
    }

    void ifft4(vector<mint> &a, int k) {
      if ((int)a.size() <= 1) return;
      if (k == 1) {
        mint a1 = a[1];
        a[1] = a[0] - a[1];
        a[0] = a[0] + a1;
        return;
      }
      int u = 1 << (k - 2);
      int v = 1;
      mint one = mint(1);
      mint imag = dy[1];
      while (u) {
        // jh = 0
        {
          int j0 = 0;
          int j1 = v;
          int j2 = v + v;
          int j3 = j2 + v;
          for (; j0 < v; ++j0, ++j1, ++j2, ++j3) {
            mint t0 = a[j0], t1 = a[j1], t2 = a[j2], t3 = a[j3];
            mint t0p1 = t0 + t1, t2p3 = t2 + t3;
            mint t0m1 = t0 - t1, t2m3 = (t2 - t3) * imag;
            a[j0] = t0p1 + t2p3, a[j2] = t0p1 - t2p3;
            a[j1] = t0m1 + t2m3, a[j3] = t0m1 - t2m3;
          }
        }
        // jh >= 1
        mint ww = one, xx = one * dy[2], yy = one;
        u <<= 2;
        for (int jh = 4; jh < u;) {
          ww = xx * xx, yy = xx * imag;
          int j0 = jh * v;
          int je = j0 + v;
          int j2 = je + v;
          for (; j0 < je; ++j0, ++j2) {
            mint t0 = a[j0], t1 = a[j0 + v], t2 = a[j2], t3 = a[j2 + v];
            mint t0p1 = t0 + t1, t2p3 = t2 + t3;
            mint t0m1 = (t0 - t1) * xx, t2m3 = (t2 - t3) * yy;
            a[j0] = t0p1 + t2p3, a[j2] = (t0p1 - t2p3) * ww;
            a[j0 + v] = t0m1 + t2m3, a[j2 + v] = (t0m1 - t2m3) * ww;
          }
          xx *= dy[__builtin_ctzll(jh += 4)];
        }
        u >>= 4;
        v <<= 2;
      }
      if (k & 1) {
        u = 1 << (k - 1);
        for (int j = 0; j < u; ++j) {
          mint ajv = a[j] - a[j + u];
          a[j] += a[j + u];
          a[j + u] = ajv;
        }
      }
    }

    void ntt(vector<mint> &a) {
      if ((int)a.size() <= 1) return;
      fft4(a, __builtin_ctz(a.size()));
    }

    void intt(vector<mint> &a) {
      if ((int)a.size() <= 1) return;
      ifft4(a, __builtin_ctz(a.size()));
      mint iv = mint(a.size()).inverse();
      for (auto &x : a) x *= iv;
    }

    vector<mint> multiply(const vector<mint> &a, const vector<mint> &b) {
      int l = a.size() + b.size() - 1;
      if (min<int>(a.size(), b.size()) <= 40) {
        vector<mint> s(l);
        for (int i = 0; i < (int)a.size(); ++i)
          for (int j = 0; j < (int)b.size(); ++j) s[i + j] += a[i] * b[j];
        return s;
      }
      int k = 2, M = 4;
      while (M < l) M <<= 1, ++k;
      setwy(k);
      vector<mint> s(M), t(M);
      for (int i = 0; i < (int)a.size(); ++i) s[i] = a[i];
      for (int i = 0; i < (int)b.size(); ++i) t[i] = b[i];
      fft4(s, k);
      fft4(t, k);
      for (int i = 0; i < M; ++i) s[i] *= t[i];
      ifft4(s, k);
      s.resize(l);
      mint invm = mint(M).inverse();
      for (int i = 0; i < l; ++i) s[i] *= invm;
      return s;
    }

    void ntt_doubling(vector<mint> &a) {
      int M = (int)a.size();
      auto b = a;
      intt(b);
      mint r = 1, zeta = mint(pr).pow((mint::get_mod() - 1) / (M << 1));
      for (int i = 0; i < M; i++) b[i] *= r, r *= zeta;
      ntt(b);
      copy(begin(b), end(b), back_inserter(a));
    }
  };

  template <typename mint>
  struct FormalPowerSeries : vector<mint> {
    using vector<mint>::vector;
    using FPS = FormalPowerSeries;

    FPS &operator+=(const FPS &r) {
      if (r.size() > this->size()) this->resize(r.size());
      for (int i = 0; i < (int)r.size(); i++) (*this)[i] += r[i];
      return *this;
    }

    FPS &operator+=(const mint &r) {
      if (this->empty()) this->resize(1);
      (*this)[0] += r;
      return *this;
    }

    FPS &operator-=(const FPS &r) {
      if (r.size() > this->size()) this->resize(r.size());
      for (int i = 0; i < (int)r.size(); i++) (*this)[i] -= r[i];
      return *this;
    }

    FPS &operator-=(const mint &r) {
      if (this->empty()) this->resize(1);
      (*this)[0] -= r;
      return *this;
    }

    FPS &operator*=(const mint &v) {
      for (int k = 0; k < (int)this->size(); k++) (*this)[k] *= v;
      return *this;
    }

    FPS &operator/=(const FPS &r) {
      if (this->size() < r.size()) {
        this->clear();
        return *this;
      }
      int n = this->size() - r.size() + 1;
      if ((int)r.size() <= 64) {
        FPS f(*this), g(r);
        g.shrink();
        mint coeff = g.back().inverse();
        for (auto &x : g) x *= coeff;
        int deg = (int)f.size() - (int)g.size() + 1;
        int gs = g.size();
        FPS quo(deg);
        for (int i = deg - 1; i >= 0; i--) {
          quo[i] = f[i + gs - 1];
          for (int j = 0; j < gs; j++) f[i + j] -= quo[i] * g[j];
        }
        *this = quo * coeff;
        this->resize(n, mint(0));
        return *this;
      }
      return *this = ((*this).rev().pre(n) * r.rev().inv(n)).pre(n).rev();
    }

    FPS &operator%=(const FPS &r) {
      *this -= *this / r * r;
      shrink();
      return *this;
    }

    FPS operator+(const FPS &r) const { return FPS(*this) += r; }
    FPS operator+(const mint &v) const { return FPS(*this) += v; }
    FPS operator-(const FPS &r) const { return FPS(*this) -= r; }
    FPS operator-(const mint &v) const { return FPS(*this) -= v; }
    FPS operator*(const FPS &r) const { return FPS(*this) *= r; }
    FPS operator*(const mint &v) const { return FPS(*this) *= v; }
    FPS operator/(const FPS &r) const { return FPS(*this) /= r; }
    FPS operator%(const FPS &r) const { return FPS(*this) %= r; }
    FPS operator-() const {
      FPS ret(this->size());
      for (int i = 0; i < (int)this->size(); i++) ret[i] = -(*this)[i];
      return ret;
    }

    void shrink() {
      while (this->size() && this->back() == mint(0)) this->pop_back();
    }

    FPS rev() const {
      FPS ret(*this);
      reverse(begin(ret), end(ret));
      return ret;
    }

    FPS dot(FPS r) const {
      FPS ret(min(this->size(), r.size()));
      for (int i = 0; i < (int)ret.size(); i++) ret[i] = (*this)[i] * r[i];
      return ret;
    }

    FPS pre(int sz) const {
      return FPS(begin(*this), begin(*this) + min((int)this->size(), sz));
    }

    FPS operator>>(int sz) const {
      if ((int)this->size() <= sz) return {};
      FPS ret(*this);
      ret.erase(ret.begin(), ret.begin() + sz);
      return ret;
    }

    FPS operator<<(int sz) const {
      FPS ret(*this);
      ret.insert(ret.begin(), sz, mint(0));
      return ret;
    }

    FPS diff() const {
      const int n = (int)this->size();
      FPS ret(max(0, n - 1));
      mint one(1), coeff(1);
      for (int i = 1; i < n; i++) {
        ret[i - 1] = (*this)[i] * coeff;
        coeff += one;
      }
      return ret;
    }

    FPS integral() const {
      const int n = (int)this->size();
      FPS ret(n + 1);
      ret[0] = mint(0);
      if (n > 0) ret[1] = mint(1);
      auto mod = mint::get_mod();
      for (int i = 2; i <= n; i++) ret[i] = (-ret[mod % i]) * (mod / i);
      for (int i = 0; i < n; i++) ret[i + 1] *= (*this)[i];
      return ret;
    }

    mint eval(mint x) const {
      mint r = 0, w = 1;
      for (auto &v : *this) r += w * v, w *= x;
      return r;
    }

    FPS log(int deg = -1) const {
      assert((*this)[0] == mint(1));
      if (deg == -1) deg = (int)this->size();
      return (this->diff() * this->inv(deg)).pre(deg - 1).integral();
    }

    FPS pow(int64_t k, int deg = -1) const {
      const int n = (int)this->size();
      if (deg == -1) deg = n;
      for (int i = 0; i < n; i++) {
        if ((*this)[i] != mint(0)) {
          if (i * k > deg) return FPS(deg, mint(0));
          mint rev = mint(1) / (*this)[i];
          FPS ret =
              (((*this * rev) >> i).log(deg) * k).exp(deg) * ((*this)[i].pow(k));
          ret = (ret << (i * k)).pre(deg);
          if ((int)ret.size() < deg) ret.resize(deg, mint(0));
          return ret;
        }
      }
      return FPS(deg, mint(0));
    }

    static void *ntt_ptr;
    static void set_fft();
    FPS &operator*=(const FPS &r);
    void ntt();
    void intt();
    void ntt_doubling();
    static int ntt_pr();
    FPS inv(int deg = -1) const;
    FPS exp(int deg = -1) const;
  };
  template <typename mint>
  void *FormalPowerSeries<mint>::ntt_ptr = nullptr;

  /**
  * @brief 多項式/形式的冪級数ライブラリ
  * @docs docs/fps/formal-power-series.md
  */

  template <typename mint>
  void FormalPowerSeries<mint>::set_fft() {
    if (!ntt_ptr) ntt_ptr = new NTT<mint>;
  }

  template <typename mint>
  FormalPowerSeries<mint> &FormalPowerSeries<mint>::operator*=(
      const FormalPowerSeries<mint> &r) {
    if (this->empty() || r.empty()) {
      this->clear();
      return *this;
    }
    set_fft();
    auto ret = static_cast<NTT<mint> *>(ntt_ptr)->multiply(*this, r);
    return *this = FormalPowerSeries<mint>(ret.begin(), ret.end());
  }

  template <typename mint>
  void FormalPowerSeries<mint>::ntt() {
    set_fft();
    static_cast<NTT<mint> *>(ntt_ptr)->ntt(*this);
  }

  template <typename mint>
  void FormalPowerSeries<mint>::intt() {
    set_fft();
    static_cast<NTT<mint> *>(ntt_ptr)->intt(*this);
  }

  template <typename mint>
  void FormalPowerSeries<mint>::ntt_doubling() {
    set_fft();
    static_cast<NTT<mint> *>(ntt_ptr)->ntt_doubling(*this);
  }

  template <typename mint>
  int FormalPowerSeries<mint>::ntt_pr() {
    set_fft();
    return static_cast<NTT<mint> *>(ntt_ptr)->pr;
  }

  template <typename mint>
  FormalPowerSeries<mint> FormalPowerSeries<mint>::inv(int deg) const {
    assert((*this)[0] != mint(0));
    if (deg == -1) deg = (int)this->size();
    FormalPowerSeries<mint> res(deg);
    res[0] = {mint(1) / (*this)[0]};
    for (int d = 1; d < deg; d <<= 1) {
      FormalPowerSeries<mint> f(2 * d), g(2 * d);
      for (int j = 0; j < min((int)this->size(), 2 * d); j++) f[j] = (*this)[j];
      for (int j = 0; j < d; j++) g[j] = res[j];
      f.ntt();
      g.ntt();
      for (int j = 0; j < 2 * d; j++) f[j] *= g[j];
      f.intt();
      for (int j = 0; j < d; j++) f[j] = 0;
      f.ntt();
      for (int j = 0; j < 2 * d; j++) f[j] *= g[j];
      f.intt();
      for (int j = d; j < min(2 * d, deg); j++) res[j] = -f[j];
    }
    return res.pre(deg);
  }

  template <typename mint>
  FormalPowerSeries<mint> FormalPowerSeries<mint>::exp(int deg) const {
    using fps = FormalPowerSeries<mint>;
    assert((*this).size() == 0 || (*this)[0] == mint(0));
    if (deg == -1) deg = this->size();

    fps inv;
    inv.reserve(deg + 1);
    inv.push_back(mint(0));
    inv.push_back(mint(1));

    auto inplace_integral = [&](fps &F) -> void {
      const int n = (int)F.size();
      auto mod = mint::get_mod();
      while ((int)inv.size() <= n) {
        int i = inv.size();
        inv.push_back((-inv[mod % i]) * (mod / i));
      }
      F.insert(begin(F), mint(0));
      for (int i = 1; i <= n; i++) F[i] *= inv[i];
    };

    auto inplace_diff = [](fps &F) -> void {
      if (F.empty()) return;
      F.erase(begin(F));
      mint coeff = 1, one = 1;
      for (int i = 0; i < (int)F.size(); i++) {
        F[i] *= coeff;
        coeff += one;
      }
    };

    fps b{1, 1 < (int)this->size() ? (*this)[1] : 0}, c{1}, z1, z2{1, 1};
    for (int m = 2; m < deg; m *= 2) {
      auto y = b;
      y.resize(2 * m);
      y.ntt();
      z1 = z2;
      fps z(m);
      for (int i = 0; i < m; ++i) z[i] = y[i] * z1[i];
      z.intt();
      fill(begin(z), begin(z) + m / 2, mint(0));
      z.ntt();
      for (int i = 0; i < m; ++i) z[i] *= -z1[i];
      z.intt();
      c.insert(end(c), begin(z) + m / 2, end(z));
      z2 = c;
      z2.resize(2 * m);
      z2.ntt();
      fps x(begin(*this), begin(*this) + min<int>(this->size(), m));
      x.resize(m);
      inplace_diff(x);
      x.push_back(mint(0));
      x.ntt();
      for (int i = 0; i < m; ++i) x[i] *= y[i];
      x.intt();
      x -= b.diff();
      x.resize(2 * m);
      for (int i = 0; i < m - 1; ++i) x[m + i] = x[i], x[i] = mint(0);
      x.ntt();
      for (int i = 0; i < 2 * m; ++i) x[i] *= z2[i];
      x.intt();
      x.pop_back();
      inplace_integral(x);
      for (int i = m; i < min<int>(this->size(), 2 * m); ++i) x[i] += (*this)[i];
      fill(begin(x), begin(x) + m, mint(0));
      x.ntt();
      for (int i = 0; i < 2 * m; ++i) x[i] *= y[i];
      x.intt();
      b.insert(end(b), begin(x) + m, end(x));
    }
    return fps{begin(b), begin(b) + deg};
  }

  /**
  * @brief NTT mod用FPSライブラリ
  * @docs docs/fps/ntt-friendly-fps.md
  */

  template <uint32_t mod>
  struct LazyMontgomeryModInt {
    using mint = LazyMontgomeryModInt;
    using i32 = int32_t;
    using u32 = uint32_t;
    using u64 = uint64_t;

    static constexpr u32 get_r() {
      u32 ret = mod;
      for (i32 i = 0; i < 4; ++i) ret *= 2 - mod * ret;
      return ret;
    }

    static constexpr u32 r = get_r();
    static constexpr u32 n2 = -u64(mod) % mod;
    static_assert(r * mod == 1, "invalid, r * mod != 1");
    static_assert(mod < (1 << 30), "invalid, mod >= 2 ^ 30");
    static_assert((mod & 1) == 1, "invalid, mod % 2 == 0");

    u32 a;

    constexpr LazyMontgomeryModInt() : a(0) {}
    constexpr LazyMontgomeryModInt(const int64_t &b)
        : a(reduce(u64(b % mod + mod) * n2)){};

    static constexpr u32 reduce(const u64 &b) {
      return (b + u64(u32(b) * u32(-r)) * mod) >> 32;
    }

    constexpr mint &operator+=(const mint &b) {
      if (i32(a += b.a - 2 * mod) < 0) a += 2 * mod;
      return *this;
    }

    constexpr mint &operator-=(const mint &b) {
      if (i32(a -= b.a) < 0) a += 2 * mod;
      return *this;
    }

    constexpr mint &operator*=(const mint &b) {
      a = reduce(u64(a) * b.a);
      return *this;
    }

    constexpr mint &operator/=(const mint &b) {
      *this *= b.inverse();
      return *this;
    }

    constexpr mint operator+(const mint &b) const { return mint(*this) += b; }
    constexpr mint operator-(const mint &b) const { return mint(*this) -= b; }
    constexpr mint operator*(const mint &b) const { return mint(*this) *= b; }
    constexpr mint operator/(const mint &b) const { return mint(*this) /= b; }
    constexpr bool operator==(const mint &b) const {
      return (a >= mod ? a - mod : a) == (b.a >= mod ? b.a - mod : b.a);
    }
    constexpr bool operator!=(const mint &b) const {
      return (a >= mod ? a - mod : a) != (b.a >= mod ? b.a - mod : b.a);
    }
    constexpr mint operator-() const { return mint() - mint(*this); }

    constexpr mint pow(u64 n) const {
      mint ret(1), mul(*this);
      while (n > 0) {
        if (n & 1) ret *= mul;
        mul *= mul;
        n >>= 1;
      }
      return ret;
    }

    constexpr mint inverse() const { return pow(mod - 2); }

    friend ostream &operator<<(ostream &os, const mint &b) {
      return os << b.get();
    }

    friend istream &operator>>(istream &is, mint &b) {
      int64_t t;
      is >> t;
      b = LazyMontgomeryModInt<mod>(t);
      return (is);
    }

    constexpr u32 get() const {
      u32 ret = reduce(a);
      return ret >= mod ? ret - mod : ret;
    }

    static constexpr u32 get_mod() { return mod; }
  };

  template <typename T>
  struct Binomial {
    vector<T> f, g, h;
    Binomial(int MAX = 0) {
      assert(T::get_mod() != 0 && "Binomial<mint>()");
      f.resize(1, T{1});
      g.resize(1, T{1});
      h.resize(1, T{1});
      while (MAX >= (int)f.size()) extend();
    }

    void extend() {
      int n = f.size();
      int m = n * 2;
      f.resize(m);
      g.resize(m);
      h.resize(m);
      for (int i = n; i < m; i++) f[i] = f[i - 1] * T(i);
      g[m - 1] = f[m - 1].inverse();
      h[m - 1] = g[m - 1] * f[m - 2];
      for (int i = m - 2; i >= n; i--) {
        g[i] = g[i + 1] * T(i + 1);
        h[i] = g[i] * f[i - 1];
      }
    }

    T fac(int i) {
      if (i < 0) return T(0);
      while (i >= (int)f.size()) extend();
      return f[i];
    }

    T finv(int i) {
      if (i < 0) return T(0);
      while (i >= (int)g.size()) extend();
      return g[i];
    }

    T inv(int i) {
      if (i < 0) return -inv(-i);
      while (i >= (int)h.size()) extend();
      return h[i];
    }

    T C(int n, int r) {
      if (n < 0 || n < r || r < 0) return T(0);
      return fac(n) * finv(n - r) * finv(r);
    }

    inline T operator()(int n, int r) { return C(n, r); }

    template <typename I>
    T multinomial(const vector<I> &r) {
      static_assert(is_integral<I>::value == true);
      int n = 0;
      for (auto &x : r) {
        if (x < 0) return T(0);
        n += x;
      }
      T res = fac(n);
      for (auto &x : r) res *= finv(x);
      return res;
    }

    template <typename I>
    T operator()(const vector<I> &r) {
      return multinomial(r);
    }

    T C_naive(int n, int r) {
      if (n < 0 || n < r || r < 0) return T(0);
      T ret = T(1);
      r = min(r, n - r);
      for (int i = 1; i <= r; ++i) ret *= inv(i) * (n--);
      return ret;
    }

    T P(int n, int r) {
      if (n < 0 || n < r || r < 0) return T(0);
      return fac(n) * finv(n - r);
    }

    T H(int n, int r) {
      if (n < 0 || r < 0) return T(0);
      return r == 0 ? 1 : C(n + r - 1, r);
    }
  };

  // #include "fps/arbitrary-fps.hpp"
  //
  using namespace Nyaan;
  using mint = LazyMontgomeryModInt<998244353>;
  // using mint = LazyMontgomeryModInt<1000000007>;
  using vm = vector<mint>;
  using vvm = vector<vm>;
  Binomial<mint> C;
  using fps = FormalPowerSeries<mint>;
  using namespace Nyaan;

  fps naive(int N, int M, vi a) {
    fps res(M + 1);
    sort(all(a));
    do {
      int c = 0;
      rep(i, N - 1) c += a[i] != a[i + 1];
      rep(i, M + 1) res[i] += mint{c}.pow(i);
    } while (nxp(a));
    map<int, int> freq;
    each(x, a) freq[x]++;
    each2(k, v, freq) res *= C.fac(v);
    return res;
  }

  fps calc(int N, int M, vi a) {
    map<int, int> freq;
    each(x, a) freq[x]++;
    deque<fps> fs;
    each2(_, n, freq) {
      fps f(n);
      rep(m, n) f[m] = C(n - 1, m) * C.finv(n - m);
      f *= C.fac(n);
      fs.push_back(f);
    }
    while (sz(fs) >= 2) {
      fps f = fs.back();
      fs.pop_back();
      fps g = fs.back();
      fs.pop_back();
      fs.push_front(f * g);
    }
    fps f = fs.back();
    f.resize(N);
    rep(i, N) f[i] *= C.fac(N - i);
    // パスカル変換
    // trc(f);
    rep(i, N) f[i] *= C.fac(i);
    f = f.rev();
    fps inve(N);
    rep(i, N) inve[i] = C.finv(i) * (i % 2 ? -1 : 1);
    fps g = (f * inve).pre(N);
    g = g.rev();
    rep(i, N) g[i] *= C.finv(i);
    g = g.rev();
    // trc(g);
    using frac = fps_fraction<fps>;
    deque<frac> hs;
    rep(s, N) {
      fps p = {g[s]};
      fps q = {1, -s};
      hs.emplace_back(p, q);
    }
    while (sz(hs) >= 2) {
      auto b = hs.back();
      hs.pop_back();
      auto c = hs.back();
      hs.pop_back();
      hs.push_front(b + c);
    }
    auto hf = hs.back();
    auto h = hf.p * (hf.q.inv(M + 1));
    h = h.pre(M + 1);
    // trc(h);
    return h;
  }

  void test() {
    mt19937_64 rng(58);
    rep(t, 1000) {
      int N = rng() % 8 + 1;
      vi a(N);
      each(x, a) x = rng() % N + 1;
      int M = rng() % 100 + 1;
      auto ans1 = calc(N, M, a);
      auto ans2 = naive(N, M, a);
      assert(ans1 == ans2);
    }
    cerr << "OK" << endl;
  }

  void q() {
    ini(N, M);
    vi a(N);
    in(a);
    auto ans = calc(N, M, a);
    rep1(i, M) out(ans[i]);
  }

  void Nyaan::solve() {
    // test();
    int T = 1;
    // in(T);
    while (T--) q();
  }
}

abc165b{
  ll X;
  cin >> X;
  ll l = 0, r = 8e18;

  ll x = 100;
  int ans = 0;
  while (x < X) {
    x = x + x / 100;
    ans++;
  }
  cout << ans << endl;
}

abc165c{
  int N, M, Q, a[50], b[50], c[50], d[50];
  //---------------------------------------------------------------------------------------------------
  int ans = 0;
  int A[10];
  void dfs(int cu = 0, int lst = 1) {
      if (cu == N) {
          int tot = 0;
          rep(i, 0, Q) if (A[b[i]] - A[a[i]] == c[i]) tot += d[i];
          chmax(ans, tot);
          return;
      }

      rep(nxt, lst, M + 1) {
          A[cu] = nxt;
          dfs(cu + 1, nxt);
      }
  }
  //---------------------------------------------------------------------------------------------------
  void _main() {
      cin >> N >> M >> Q;
      rep(i, 0, Q) {
          cin >> a[i] >> b[i] >> c[i] >> d[i];
          a[i]--; b[i]--;
      }

      dfs();
      cout << ans << endl;
  }
}

abc165d{
  ll A, B, N;
  //---------------------------------------------------------------------------------------------------
  ll f(ll x) { return (A * x) / B - A * (x / B); }
  //---------------------------------------------------------------------------------------------------
  void _main() {
      cin >> A >> B >> N;

      ll ans = 0;
      chmax(ans, f(N));
      if (B - 1 <= N) chmax(ans, f(B - 1));
      cout << ans << endl;
  }
}

abc165e{
  int N, M;
  //---------------------------------------------------------------------------------------------------
  void _main() {
      cin >> N >> M;

      if (M == 1) {
          printf("1 2\n");
          return;
      }

      int i1 = 1;
      int i2 = M + 2;

      rrep(diff, M, 1) {
          printf("%d %d\n", i1, i1 + diff);
          i1++;
          swap(i1, i2);
      }
  }
}

abc165f{
  int N, a[201010];
  vector<int> E[201010];
  //---------------------------------------------------------------------------------------------------
  PersistentSegmentTree pst;
  int ans[201010];
  void dfs(int cu = 0, int pa = -1, int root = 0) {
      int root2 = root;
      int ma = pst.get(root, 0, a[cu]);
      pst.update(root2, a[cu], max(pst.get(root, a[cu], a[cu] + 1), ma + 1));

      ans[cu] = pst.get(root2, 0, N);
      fore(to, E[cu]) if (to != pa) dfs(to, cu, root2);
  }
  //---------------------------------------------------------------------------------------------------
  void _main() {
      cin >> N;
      rep(i, 0, N) cin >> a[i];
      compress1(a, N);

      rep(i, 0, N - 1) {
          int u, v; cin >> u >> v;
          u--; v--;
          E[u].push_back(v);
          E[v].push_back(u);
      }

      pst.init(N);
      dfs();

      rep(i, 0, N) printf("%d\n", ans[i]);
  }
}

abc164d{
  string S;
  ll cnt[2020];
  //---------------------------------------------------------------------------------------------------
  void _main() {
      cin >> S;
      int N = S.length();

      ll ans = 0;
      cnt[0] = 1;
      int tot = 0;
      int p = 1;
      rrep(i, N - 1, 0) {
          tot = (tot + (S[i] - '0') * p) % 2019;
          
          ans += cnt[tot];

          p = (p * 10) % 2019;
          cnt[tot]++;
      }
      cout << ans << endl;
  }
}

abc164e{
  int N, M, S;
  vector<pair<int,int>> E[50];
  int A[101], B[101], C[50], D[50];
  ll dist[50][3010];
  template<typename T> using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;
  bool vis[50][3010];
  ll ans[50];
  //---------------------------------------------------------------------------------------------------
  void _main() {
      cin >> N >> M >> S;
      chmin(S, 3000);
      rep(i, 0, M) {
          int u, v; cin >> u >> v; u--; v--;
          cin >> A[i] >> B[i];
          E[u].push_back({ v, i });
          E[v].push_back({ u, i });
      }
      rep(i, 0, N) cin >> C[i] >> D[i];

      rep(i, 0, N) rep(s, 0, 3001) dist[i][s] = infl;
      rep(i, 0, N) rep(s, 0, 3001) vis[i][s] = false;
      rep(i, 0, N) ans[i] = infl;

      min_priority_queue<pair<ll, int>> que;

      dist[0][S] = 0;
      que.push({ 0, 0 * 5010 + S });

      while (!que.empty()) {
          auto q = que.top(); que.pop();

          ll cst = q.first;
          int cu = q.second / 5010;
          int s = q.second % 5010;

          if (vis[cu][s]) continue;
          vis[cu][s] = true;

          chmin(ans[cu], cst);

          fore(p, E[cu]) {
              int to = p.first;
              int i = p.second;
              if (s < A[i]) continue;

              ll cst2 = cst + B[i];
              if (chmin(dist[to][s - A[i]], cst2)) que.push({ dist[to][s - A[i]], to * 5010 + s - A[i] });
          }

          ll cst2 = cst + D[cu];
          int s2 = min(3000, s + C[cu]);
          if (chmin(dist[cu][s2], cst2)) que.push({ dist[cu][s2], cu * 5010 + s2 });
      }

      rep(i, 1, N) printf("%lld\n", ans[i]);
  }
}

abc164d2{
  #include <bits/stdc++.h>
  using namespace std;

  long long solve(const string &S) {
      int N = S.size();
      vector<long long> val(2019, 0);
      long long fac = 1;
      long long cur = 0;
      val[cur]++;
      for (int i = 0; i < N; ++i) {
          long long add = S[N-1-i] - '0';
          cur = (cur + fac * add) % 2019;
          fac = (fac * 10) % 2019;
          val[cur]++;
      }
      long long res = 0;
      for (int i = 0; i < val.size(); ++i) {
          res += val[i] * (val[i] - 1) / 2;
      }
      return res;
  }

  int main() {
      string S;
      cin >> S;
      cout << solve(S) << endl;
  }
}

abc164f{
  #include <bits/stdc++.h>

  using namespace std;

  void fail() {
    cout << -1 << endl;
    exit(0);
  }

  int main() {
    int N;
    cin >> N;
    string A[500], C[500];
    uint64_t B[500], D[500];
    int H = N, W = N;
    for(int i = 0; i < N; i++) {
      int x;
      cin >> x;
      if(x == 0) A[i] = "and";
      else A[i] = "or";
    }

    for(int i = 0; i < N; i++) {
      int x;
      cin >> x;
      if(x == 0) C[i] = "and";
      else C[i] = "or";
    }
    for(int i = 0; i < N; i++) {
      cin >> B[i];
    }
    for(int i = 0; i < N; i++) {
      cin >> D[i];
    }

    uint64_t ans[500][500] = {{}};
    for(int i = 0; i < 64; i++) {
      vector< vector< int > > decide(H, vector< int >(W, -1));
      vector< pair< int, int > > latte, malta;

      for(int j = 0; j < H; j++) {
        if(A[j] == "and") {
          if((B[j] >> i) & 1) for(int k = 0; k < W; k++) decide[j][k] = 1;
          else latte.emplace_back(j, 0);
        } else {
          if((~B[j] >> i) & 1) for(int k = 0; k < W; k++) decide[j][k] = 0;
          else latte.emplace_back(j, 1);
        }
      }
      for(int j = 0; j < W; j++) {
        if(C[j] == "and") {
          if((D[j] >> i) & 1) {
            for(int k = 0; k < H; k++) if(decide[k][j] == 0) fail();
            for(int k = 0; k < H; k++) decide[k][j] = 1;
          } else malta.emplace_back(j, 0);
        } else {
          if((~D[j] >> i) & 1) {
            for(int k = 0; k < H; k++) if(decide[k][j] == 1) fail();
            for(int k = 0; k < H; k++) decide[k][j] = 0;
          } else malta.emplace_back(j, 1);
        }
      }

      if(min(latte.size(), malta.size()) >= 2) {
        for(int j = 0; j < latte.size(); j++) {
          for(int k = 0; k < malta.size(); k++) {
            decide[latte[j].first][malta[k].first] = (j + k) & 1;
          }
        }
      } else if(latte.size() == 1) {
        for(auto &p : malta) {
          bool ex = false;
          for(int j = 0; j < H; j++) ex |= decide[j][p.first] == p.second;
          decide[latte[0].first][p.first] = ex ? latte[0].second : p.second;
        }
        bool f = false;
        for(int k = 0; k < W; k++) f |= decide[latte[0].first][k] == latte[0].second;
        if(!f) fail();
      } else if(malta.size() == 1) {
        for(auto &p : latte) {
          bool ex = false;
          for(int k = 0; k < W; k++) ex |= decide[p.first][k] == p.second;
          decide[p.first][malta[0].first] = ex ? malta[0].second : p.second;
        }
        bool f = false;
        for(int j = 0; j < H; j++) f |= decide[j][malta[0].first] == malta[0].second;
        if(!f) fail();
      } else {
        for(auto &p : latte) {
          bool f = false;
          for(int k = 0; k < W; k++) f |= decide[p.first][k] == p.second;
          if(!f) fail();
        }
        for(auto &p : malta) {
          bool f = false;
          for(int j = 0; j < H; j++) f |= decide[j][p.first] == p.second;
          if(!f) fail();
        }
      }
      for(int j = 0; j < H; j++) {
        for(int k = 0; k < W; k++) {
          ans[j][k] |= ((uint64_t) (decide[j][k] & 1)) << i;
        }
      }
    }

    for(int i = 0; i < H; i++) {
      for(int j = 0; j < W; j++) cout << ans[i][j] << " ";
      cout << endl;
    }
  }

}

abc163e{
  #include "bits/stdc++.h"
  using namespace std;
  typedef long long ll;

  int main() {
      int n; cin >> n;
      vector<pair<ll, int>> a(n);
      for (int i = 0; i < n; i++) {
          cin >> a[i].first;
          a[i].second = i + 1;
      }
      sort(a.rbegin(), a.rend());
      vector<vector<ll>> dp(n + 1, vector<ll>(n + 1, 0));
      dp[0][0] = 0;
      for (int k = 1; k <= n; k++) {
          for (int i = 0; i <= k; i++) {
              int j = k - i;
              if (i - 1 >= 0) dp[i][j] = max(dp[i][j], dp[i - 1][j] + a[k - 1].first * (a[k - 1].second - i));
              if (j - 1 >= 0) dp[i][j] = max(dp[i][j], dp[i][j - 1] + a[k - 1].first * (n - j + 1 - a[k - 1].second));
          }
      }
      ll ans = 0;
      for (int i = 0; i <= n; i++) {
          ans = max(ans, dp[i][n - i]);
      }
      cout << ans << endl;
      return 0;
  }
}

abc163d{
  #include <iostream>
  #include <atcoder/modint>

  int main() {
      long long N, K;
      std::cin >> N >> K;
      atcoder::modint1000000007 ans = (N-K+2) * (N*N+N*K-2*K*K+N+2*K+6) / 6;
      std::cout << ans.val() << std::endl;
      return 0;
  }
}

abc163f{
  #include <bits/stdc++.h>
  using namespace std;
  template<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}
  template<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}
  using Int = long long;
  const char newl = '\n';


  template<typename F>
  struct FixPoint : F{
    FixPoint(F&& f):F(forward<F>(f)){}
    template<typename... Args>
    decltype(auto) operator()(Args&&... args) const{
      return F::operator()(*this,forward<Args>(args)...);
    }
  };
  template<typename F>
  inline decltype(auto) MFP(F&& f){
    return FixPoint<F>{forward<F>(f)};
  }

  //INSERT ABOVE HERE
  signed main(){
    cin.tie(0);
    ios::sync_with_stdio(0);

    int n;
    cin>>n;
    vector<int> cs(n);
    for(int i=0;i<n;i++) cin>>cs[i],cs[i]--;

    vector<vector<int>> G(n);
    for(int i=1;i<n;i++){
      int a,b;
      cin>>a>>b;
      a--;b--;
      G[a].emplace_back(b);
      G[b].emplace_back(a);
    }

    using ll = long long;
    ll all=0;
    vector<ll> cnt(n,0),sub(n,0);

    vector<ll> ans(n,(ll)n*(n-1)/2);
    MFP([&](auto dfs,int v,int p)->int{
      sub[v]=1;
      ll bfr=cnt[cs[v]];
      for(int u:G[v]){
        if(u==p) continue;
        ll pre=all-cnt[cs[v]];
        sub[v]+=dfs(u,v);
        ll nxt=all-cnt[cs[v]];
        ans[cs[v]]-=(nxt-pre)*(nxt-pre-1)/2;
      }
      cnt[cs[v]]=bfr+sub[v];
      all++;
      return sub[v];
    })(0,-1);

    for(int c=0;c<n;c++){
      ll pre=0,nxt=n-cnt[c];
      ans[c]-=(nxt-pre)*(nxt-pre-1)/2;
    }
    for(int c:cs) ans[c]++;

    for(ll a:ans) cout<<a<<newl;
    return 0;
  }

}

abc162e{
  int N, K;
  mint cnt[101010];
  //---------------------------------------------------------------------------------------------------
  void _main() {
      cin >> N >> K;

      rrep(g, K, 1) {
          cnt[g] = mint(K / g) ^ N;
          int gg = g * 2;
          while (gg <= K) {
              cnt[g] -= cnt[gg];
              gg += g;
          }
      }

      mint ans = 0;
      rep(g, 1, K + 1) ans += cnt[g] * g;
      cout << ans << endl;
  }
}

abc162d{
  int N; string S;
  int R = 1, G = 2, B = 4;
  int RGB = 7;
  int cnt[8];
  //---------------------------------------------------------------------------------------------------
  void _main() {
      cin >> N >> S;
      fore(c, S) {
          if (c == 'R') c = R;
          else if (c == 'G') c = G;
          else c = B;
      }

      int r = 0, g = 0, b = 0;
      ll ans = 0;
      rep(j, 0, N) {
          rep(k, j + 1, N) {
              if (S[j] == S[k]) continue;

              int Si = RGB - S[j] - S[k];
              ans += cnt[Si];

              int i = j - (k - j);
              if (0 <= i) {
                  int msk = S[i] | S[j] | S[k];
                  if (msk == RGB) ans--;
              }
          }

          cnt[S[j]]++;
      }
      cout << ans << endl;
  }
}


abc162f{
  int N, A[201010];
  ll dp[201010][2][4][3];
  //---------------------------------------------------------------------------------------------------
  void _main() {
      cin >> N;
      rep(i, 0, N) cin >> A[i];

      rep(i, 0, N + 1) rep(top, 0, 2) rep(two, 0, 3) rep(three, 0, 2) dp[i][top][two][three] = -infl;

      dp[0][0][0][0] = 0;

      dp[1][1][0][0] = A[0];
      dp[2][0][0][0] = A[1];
      dp[3][0][1][0] = A[2];

      rep(i, 0, N) rep(top, 0, 2) rep(two, 0, 3) rep(three, 0, 2) if(-infl < dp[i][top][two][three]) {
          chmax(dp[i + 2][top][two][three], dp[i][top][two][three] + A[i + 1]);
          chmax(dp[i + 3][top][two + 1][three], dp[i][top][two][three] + A[i + 2]);
          chmax(dp[i + 4][top][two][three + 1], dp[i][top][two][three] + A[i + 3]);
      }

      ll ans = -infl;
      rep(i, 1, N + 1) rep(top, 0, 2) rep(two, 0, 3) rep(three, 0, 2) if (-infl < dp[i][top][two][three]) {
          int cnt = 0;
          int tot = i;
          if (top == 1) cnt++, tot--;

          tot -= two;
          tot -= three * 2;

          cnt += tot / 2;

          if (cnt == N / 2) chmax(ans, dp[i][top][two][three]);
      }
      cout << ans << endl;
  }
}

abc262c{
  #include <bits/stdc++.h>
  using namespace std;

  int main() {
      int n;
      cin >> n;
      vector<int> a(n);
      int same = 0;
      for (int i = 0; i < n; ++i) {
          cin >> a[i];
          a[i] -= 1;
          if (a[i] == i) {
              same += 1;
          }
      }
      long long ans = (long long)same * (same - 1) / 2;
      for (int i = 0; i < n; ++i) {
          if (a[i] > i and a[a[i]] == i) {
              ans += 1;
          }
      }
      cout << ans << '\n';
      return 0;
  }

}

abc262d{
  #include <bits/stdc++.h>
  #include <atcoder/modint>
  using namespace std;
  using namespace atcoder;
  using mint = modint998244353;

  int main() {
      
    int N;
    cin>>N;
    
    vector<int> a(N);
    for(int i=0;i<N;i++)cin>>a[i];
    
    mint ans = 0;
    
    for(int i=1;i<=N;i++){
      vector dp(N+1,vector(i+1,vector<mint>(i,0)));
      dp[0][0][0] = 1;
      for(int j=0;j<N;j++){
        for(int k=0;k<=i;k++){
          for(int l=0;l<i;l++){
            dp[j+1][k][l] += dp[j][k][l];
            if(k!=i)dp[j+1][k+1][(l+a[j])%i] += dp[j][k][l];
          }
        }
      }
      ans += dp[N][i][0];
    }
    
    cout<<ans.val()<<endl;
    
    return 0;
  }

}

abc262e{
  #include <bits/stdc++.h>
  #include <atcoder/modint>
  using namespace std;

  using mint = atcoder::modint998244353;

  mint fact(const int n) {
      static vector<mint> v = {1};
      while ((int)v.size() <= n) {
          v.push_back(v.back() * v.size());
      }
      return v[n];
  }

  mint inv_fact(const int n) {
      static vector<mint> u = {0, 1}, v = {1, 1};
      for (int i = (int)u.size(); i <= n; ++i) {
          u.push_back(-mint(mint::mod() / i) * u[mint::mod() % i]);
          v.push_back(v.back() * u.back());
      }
      return v[n];
  }

  mint binom(const int n, const int k) {
      return fact(n) * inv_fact(k) * inv_fact(n - k);
  }

  int main() {
      int n, m, k;
      cin >> n >> m >> k;
      vector<int> deg(n);
      while (m--) {
          int u, v;
          cin >> u >> v;
          u -= 1, v -= 1;
          deg[u] += 1, deg[v] += 1;
      }
      int odd = 0;
      for (const int x : deg) {
          if (x % 2 == 1) {
              odd += 1;
          }
      }
      mint ans = 0;
      for (int i = 0; i <= k; i += 2) {
          if (i <= odd and k - i <= n - odd) {
              ans += binom(odd, i) * binom(n - odd, k - i);
          }
      }
      cout << ans.val() << '\n';
      return 0;
  }
}