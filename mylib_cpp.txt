void 251E_TakahashiAndAnimals(){
  int n; cin >> n;
  vi a(n+1);
  REP2(i,1,n) cin >> a[i];

  ll ans = LL_INF;

  vvl dp(300005,vl(2));

  REP(t,1){
    // irenainara INF
    // irerunara dp[1][0]=0
    // ireru dp[1][1] = a[i];
    // t==1
    // dp[1][1] = a[1]
    // dp[1][0] = LL_INF

    // t==0
    // dp[1][0] = 0
    // dp[1][1] = LL_INF
    dp[1][t] = a[1]*t;
    dp[1][1-t] = LL_INF;

    REP2(i,2,n){
      dp[i][0] = dp[i-1][1];
      dp[i][1] = min(dp[i-1][0],dp[i-1][1])+a[i];
    }
    if(t==0) ans = min(ans,dp[n][1]);
    if(t==1) ans = min(ans,min(dp[n][0],dp[n][1]));
  }
  cout << ans << endl;
  return;
}

void 251B_At_Most_3(){
  int N,W; cin >> N >> W;
  vi A(N+2);
  rep(i,N) cin >> A[i];
  A[N]=A[N+1]=0;
  set<int> st;
  rep(i,N){
    rep2(j,i+1,N+1){
      rep2(k,j+1,N+2){
        int sum = 0;
        sum= A[i]+A[j]+A[k];
        if(sum<=W){
          st.insert(sum);
        }
      }
    }
  }
  int ans = st.size();
  cout << ans << endl;
  return;
} 

void 251D_At_Most_3(){
    int W; cin >> W;
    vi a;
    REP2(i,1,99){
        a.push_back(i);
        a.push_back(i*100);
        a.push_back(i*10000);
    }
    cout << a.size() << endl;
    vector_output(a);
    return;
}

void 251TwoSpanningTree(){

  int N,M;
  cin >> N >> M;
  vi G(200005);
  vb visited(200005);
  vpi T1,T2;

  void dfs(int v){
    visited[v] = true;
    for(auto u: G[v]){
      if(!visited[u]){
        T1.push_back(P(v,u));
        dfs(u);
      }
    }
  }

  void bfs(){
    REP2(i,1,N) visited[i] = false;
    que<int> Q;
    Q.push(1), visited[1] = true;

    int v;
    while(Q.size()){
      v = Q.front(), Q.pop();
      for(auto u: G[v]){
        if(!visited[u]){
          T2.push_back(P(v,u));
          visited[u] = true;
          Q.push(u);
        }
      }
    }
  }

  int u,v;
  REP2(i,1,M){
    cin >> u >> v;
    G[u].push_back(v);
    G[v].push_back(u);
  }
  dfs(1);
  bfs();

  for(auto p: T1) cout << p.first << " " << p.second << endl;
  for(auto p: T2) cout << p.first << " " << p.second << endl;
}

void 249A_Jogging(){
    int A,B,C,D,E,F,X;
    cin >> A >> B >>C >> D >> E >> F >> X;

    int takahashi = 0;
    int aoki = 0;

    rep(i,X){
        int time1 = i%(A+C);
        if(time1<A) takahashi+=B;
        
        int time2 = i%(D+F);
        if(time2<D) aoki+=E;
    }
    if(aoki<takahashi) cout << "Takahashi" << endl;
    else if(aoki == takahashi) cout << "Draw" << endl;
    else cout << "Aoki" << endl;
}

void algo_linked_list(){
    struct Node {
        Node* nex;  // 次がどのノードを指すか
        Node* pre;
        string value;  // ノードに付随している値
        Node(const string& value = "") : nex(NULL), value(value) { }
    };

    // 番兵を表すノード (ここではグローバルに置いておく)
    Node* nil;

    // 連結リストの初期化
    void init() {
        nil = new Node();
        nil->nex = nil; // 初期状態では nil が nil を指すように
        nil->pre = nil;
    }

    // 連結リストへ先頭への要素の挿入
    void insert(Node* v) {
        v->nex = nil->nex;  // v の次を、現在の先頭に
        nil->nex = v;  // 先頭を v に書き換える
    }

    void PushHead(Node* v){
    v->nex = nil->nex;
    v->pre = nil;
    nil->nex = v;
    (v->nex)->pre = v;
    return;
    }

    string PopTail(){
    Node *tail = nil->pre;
    if(tail == nil){
        return "Error";
    }else{
        string ret = tail->value;
        nil->pre = tail->pre;
        (nil->pre)->nex = nil;
        delete tail;

        return ret;
    }
    }

    string erase(){
    Node *front = nil->nex;
    if(front == nil){
        return "Error";
    }else{
        string ret = front->value;
        nil->nex = front->nex;
        delete front;
        return ret;
    }
    }
}

void abc250e(){
    int n;  cin >> n;
  vi a(n),b(n);
  rep(i,n) cin >> a[i];
  rep(i,n) cin >> b[i];
  map<int,int> mp;
  vi ca(n),cb(n),mx(n);

  rep(i,n){
    if(!mp.count(a[i])) mp[a[i]] = mp.size()+1;
    ca[i] = mp.size();
  }  
  
  const int INF = 100100100;
  set<int> st;
  int m=0;
  rep(i,n){
    st.insert(b[i]);
    int x = mp[b[i]];
    if(x==0) x = INF;
    m = max(m,x);
    mx[i] = m;
    cb[i] = st.size();
  }
  int q; cin >> q;
  while(q--){
    int x,y; cin >> x >> y;
    x--,y--;
    if(ca[x]==cb[y] && cb[y]==mx[y]){
      cout << "Yes" << endl;
    }else{
      cout << "No" << endl;
    }
  }
}

void abc249e{
    ll n,p; cin >> n >> p;
    vvl dp(3101,vl(3101));
    vvl sum(3101,vl(3101));
    dp[0][0] = modPow(25,p-2,p)*26ll%p;
    vl ten;
    rep(i,6) ten.push_back(pow(10,i));
    REP2(i,1,n) sum[0][i] = dp[0][0];
    REP2(i,1,n){
        REP2(j,1,n){
        REP2(k,1,4){
            if(i-k-1<0) continue;
            ll x = max(j-ten[k-1]+1,0ll),y = max(j-ten[k]+1,0ll);
            dp[i][j] += (sum[i-k-1][x] -sum[i-k-1][y]+p)*25;
            dp[i][j]%=p;
        }
        sum[i][j+1] = sum[i][j] +dp[i][j];
        sum[i][j+1] %= p;
        }
    }
    ll s = 0;
    rep2(i,1,n) s+=dp[i][n];
    cout << s%p << endl;
    return;
}

void abc249f(){
    int n,k; cin >> n >> k;
  vi t(n+1),y(n+1);

  t[0]=1,y[0]=0;
  REP2(i,1,n){
    cin >> t[i] >> y[i];
  }

  ll ans = numeric_limits<ll>::min(), sum=0;

  max_heap<int> ignore;
  min_heap<int> take;

  for(int i=n;i>=0;--i){
    if(t[i]==1){
      ans = max(ans,y[i]+sum);
      k-=1;
    }else{
      if(y[i] >= 0){
        sum += y[i];
        take.push(y[i]);
      }else{
        ignore.push(y[i]);
      }
    }
    if((int)ignore.size() > k){
      if(ignore.empty()){
        break;
      }
      const int val = ignore.top();
      ignore.pop();
      sum += val;
      take.push(val);
    }
  }
  cout << ans << endl;
  return;
}

void abc247e(){
  ll N,X,Y;
  cin >> N >> X >> Y;  
  vector<int> A(N);

  rep(i,N) cin >> A[i];

  int posX{-1}, posY{-1}, B{-1};

  ll res{};
  rep(i,N){
    if(A[i]==X) posX=i;
    if(A[i]==Y) posY=i;
    if(A[i]<Y or X<A[i]) B=i;
    res += max(0,min(posX,posY)-B);
  }
  cout << res << endl;
} 

void abc246e(){

int N;
int Ax,Ay,Bx,By;
string S[1510];

int dx2[4]={1,1,-1,-1};
int dy2[4]={1,-1,1,-1};

int opt[1510][1510][5];
bool vis[1510][1510][5];

int main() {
    

    cin >> N;

    cin >> Ay >> Ax >> By >> Bx;

    Ax--,Ay--,Bx--,By--;
    rep(y,N) cin >> S[y];

    min_heap<pair<int, tuple<int,int,int>>> que;
    rep(x,N) rep(y,N) rep(dir,5) opt[y][x][dir] = INT_MAX;
    rep(x,N) rep(y,N) rep(dir,5) vis[y][x][dir] = false;

    opt[Ay][Ax][4]=0;
    que.push({0,{Ax,Ay,4}});

    while(!que.empty()){
        int x,y,dir;
        tie(x,y,dir) = que.top().second;
        que.pop();


        if(vis[y][x][dir]) continue;
        vis[y][x][dir]=true;

        if(x == Bx && y == By){
        cout << opt[y][x][dir] << endl;
        return 0;
        }
        rep(d,4){
        int xx = x+dx2[d];
        int yy = y+dy2[d];

        if(0 <=xx && xx < N && 0<= yy && yy < N){
            if(S[yy][xx] == '#') continue;
            if(chmin(opt[yy][xx][d],opt[y][x][dir]+(dir!=d))){
            que.push({opt[yy][xx][d],{xx,yy,d}});
            }
        }
        }
    }
    cout << -1 << endl;
    }
}

void algo_data_structure_linked_list_deque(){

    struct Node {
        Node* nex;  // 次がどのノードを指すか
        Node* pre;  // 前がどのノードを指すか
        string value;  // ノードに付随している値
        Node(const string& value = "") : nex(NULL), value(value) { }
    };

    Node* nil;

    void init() {
        nil = new Node();
        nil->nex = nil; // 初期状態では nil の次が nil を指すように
        nil->pre = nil; // 初期状態では nil の前が nil を指すように
    }

    // 双方向連結リストへ先頭への要素の挿入
    void PushHead(Node* v) {
        v->nex = nil->nex;  // v の次を、元の先頭要素に
        v->pre = nil;   // v の前を nil に
        nil->nex = v;  // nil の次を v に書き換える
        (v->nex)->pre = v;  // 元の先頭要素の前を v にする
        return;
    }

    // 双方向連結リストへ末尾への要素の挿入
    void PushTail(Node* v) {
        v->nex = nil;   // v の次を nil に
        v->pre = nil->pre;  // v の前を、元の末尾ノードに
        nil->pre = v;   // nil の前を v に
        (v->pre)->nex = v;  // 元の末尾ノードの次を v に
        return;
    }

    // 双方向連結リストの先頭にある文字列を返し、その要素を削除する
    string PopHead() {
        Node *head = nil->nex;  // 先頭のノードを取得する
        if(head == nil) {
            // 双方向連結リストが空なら、Error を返す
            return "Error";
        }
        else {
            string ret = head->value;   // 先頭の文字列を返す
            nil->nex = head->nex;   // nil の次を、head の次に
            (nil->nex)->pre = nil;  // 新たな先頭の前を nil に
            delete head;    // メモリを開放する

            return ret;
        }
    }

    // 双方向連結リストの末尾にある文字列を返し、その要素を削除する
    string PopTail() {
        Node *tail = nil->pre;  // 末尾のノードを取得する
        if(tail == nil) {
            // 双方向連結リストが空なら、Error を返す
            return "Error";
        }
        else {
            string ret = tail->value;   // 末尾の文字列を返す
            nil->pre = tail->pre;   // nil の前を、tail の前に
            (nil->pre)->nex = nil;  // 新たな末尾の次を nil に
            delete tail;    // メモリを開放する

            return ret;
        }
    }

    int main() {
        // 連結リストの初期化
        init(); 

        int Q;
        cin >> Q;
        for (int i = 0; i < Q; ++i) {
            int type; cin >> type;

            if(type == 0) {
                string S; cin >> S;
                Node *v = new Node(S);  // ノードを作成する
                PushHead(v);
            }
            else if(type == 1) {
                string S; cin >> S;
                Node *v = new Node(S);  // ノードを作成する
                PushTail(v);
            }
            else if(type == 2) {
                cout << PopHead() << endl;
            }
            else if(type == 3) {
                cout << PopTail() << endl;
            }
        }
    }
}

void abc180b(){
    double manhatten(vd X){
        double res=0;
        rep(i,X.size()) res+=abs(X[i]);
        return res;
    }

    double uklid(vd X){
        double res=0;
        rep(i,X.size()) res += X[i]*X[i];
        return sqrt(res);
    }

    double chebishef(vd X){
        double res=0;
        rep(i,X.size()) chmax(res,abs(X[i]));
        return res;
    }

    int main(){
        int N; cin >> N;
        vd X(N);
        rep(i,N) cin >> X[i];

        cout << fixed << setprecision(15);
        cout << manhatten(X) << endl;
        cout << uklid(X) << endl;
        cout << chebishef(X) << endl;
    }
}

void abc180c(){
    ll N; cin >> N;

    set<ll> st;
    REP2(i,1,sqrt(N)){
        if(N%i==0){
        st.insert(i);
        st.insert(N/i);
        }
    }
    // sort(st.begin(),st.end());
    for(ll v: st){
        cout << v << endl;
    }
}

void abc180e(){
    int n;
  cin >> n;
  vector<int> x(n), y(n), z(n);
  rep(i,n) cin >> x[i] >> y[i] >> z[i];
  int n2 = 1<<n;
  // dp INF initialize
  vector<vector<int>> dp(n2,vector<int>(n,INF));
  //  dist 0 initialize
  vector<vector<int>> dist(n,vector<int>(n));

  rep(i,n)rep(j,n) {
    // two dimension
    // now = x[i]-x[j]
    // two point select
    //  get dist[i][j]
    int now = abs(x[i]-x[j]);
    now += abs(y[i]-y[j]);
    now += max(0, z[j]-z[i]);
    dist[i][j] = now;
  }
  rep(i,n) {
    if (i == 0) continue;
    // update dist from 0
    dp[1<<i][i] = dist[0][i];
  }
  rep(i,n2)rep(j,n) {
    // i no hitei wo migini shift shita mono ga 1
    // 
    if (~i>>j&1) continue;
    rep(k,n) {
      if (i>>k&1) continue;
      chmin(dp[i|1<<k][k], dp[i][j]+dist[j][k]);
    }
  }
  cout << dp[n2-1][0] << endl;
  return 0;
}

void abc180f(){
    const int MX = 305;
    mint c[MX][MX];
    mint dp[MX][MX];
    
    mint f(int n, int m, int l) {
    vector<mint> path(l+1);
    path[1] = 1;
    path[2] = 1;
    for (int i = 3; i <= l; ++i) path[i] = path[i-1]*i;
    vector<mint> cycle(l+1);
    for (int i = 2; i <= l; ++i) cycle[i] = path[i-1];
    rep(i,n+1)rep(j,m+1) dp[i][j] = 0;
    dp[0][0] = 1;
    rep(i,n+1)rep(j,m+1) {
        for (int k = 1; k <= l; ++k) {
        int ni = i+k;
        int nj = j+k-1;
        if (ni > n) break;
        if (nj > m) break;
        dp[ni][nj] += dp[i][j]*c[n-i-1][k-1]*path[k];
        }
        for (int k = 2; k <= l; ++k) {
        int ni = i+k;
        int nj = j+k;
        if (ni > n) break;
        if (nj > m) break;
        dp[ni][nj] += dp[i][j]*c[n-i-1][k-1]*cycle[k];
        }
    }
    return dp[n][m];
    }
    
    int main() {
    c[0][0] = 1;
    rep(i,MX-1) {
        rep(j,i+1) {
        c[i+1][j] += c[i][j];
        c[i+1][j+1] += c[i][j];
        }
    }
    
    int n, m, l;
    cin >> n >> m >> l;
    mint ans = f(n,m,l) - f(n,m,l-1);
    cout << ans.val() << endl;
    return 0;
    }
}

void abc180c(){
  int n;
  cin >> n;
  ll ans = 0;
  for (int a = 1; a <= n; ++a) {
    ans += (n-1)/a;
  }
  cout << ans << endl;
  return 0;
}

void abc252d(){
  int main() {
  int N;
  cin >> N;
  vector< int > A(N);
  cin >> A;
  map< int, int > mp;
  for(auto &a: A) mp[a]++;
  int64 ret = 0;
  int64 a = 0, b = 0;
  for(auto&[_, p]: mp) {
    ret += b * p;
    b += a * p;
    a += p;
  }
  cout << ret << "\n";
}
}

void abc252e(){
  struct edge{
	int to,cost,idx;
};
 
vector<int> dijkstra(int s,vector<vector<edge>>&G){
	vector<ll>dist(G.size(),1LL<<60);
	vector<int>idx(G.size());
	dist[s]=0;
	using P=pair<ll,int>;
	priority_queue<P,vector<P>,greater<P>> pq;
	pq.push({0,s});
 
	while(!pq.empty()){
		auto[d,v]=pq.top();
		pq.pop();
		if(dist[v]!=d)continue;
		for(auto[vv,c,i]:G[v]){
			if(dist[vv]>dist[v]+c){
				dist[vv]=dist[v]+c;
				pq.push({dist[vv],vv});
				idx[vv]=i;  //  <- index 
			}
		}
	}
	return idx;
}
 
int main(){
	int N,M;
	cin >> N >> M;
	vector<vector<edge>>G(N);
	for(int i=0;i<M;i++){
		int a,b,c;
		cin >> a >> b >> c;
		G[a-1].push_back({b-1,c,i});
		G[b-1].push_back({a-1,c,i});
	}
	vector<int> idx=dijkstra(0,G);
	for(int i=1;i<N;i++)cout << idx[i]+1 << ' ';
}
}

void arc141a(){
  #include <bits/stdc++.h>
using namespace std;
int main(){
  vector<long long> ten(18);
  ten[0] = 1;
  for (int i = 0; i < 17; i++){
    ten[i + 1] = ten[i] * 10;
  }

  int T;
  cin >> T;
  for (int i = 0; i < T; i++){
    long long N;
    cin >> N;
    int L = to_string(N).size();
    long long ans = ten[L - 1] - 1;
    for (int j = 1; j < L; j++){
      if (L % j == 0){
        long long q = 0;
        for (int k = 0; k < L / j; k++){
          q += ten[k * j];
        }
        long long p = N / q * q;
        ans = max(ans, p);
      }
    }
    cout << ans << endl;
  }
}
}



void abc253c{
    #include <bits/stdc++.h>
    using namespace std;

    int main() {
        int q;
        cin >> q;
        multiset<int> st;
        while (q--) {
            int t;
            cin >> t;
            if (t == 1) {
                int x;
                cin >> x;
                st.insert(x);
            } else if (t == 2) {
                int x, c;
                cin >> x >> c;
                while (c-- and st.find(x) != st.end()) {
                    st.erase(st.find(x));
                }
            } else {
                cout << *st.rbegin() - *st.begin() << endl;
            }
        }
    }
}

void abc253d(){
    void solve() {
    LL(N, a, b);
    ll g = gcd(a, b);
    ll lcm = a * b / g;
    
    auto f = [&](ll d) -> ll {
        ll n = N / d;
        return n * (n + 1) / 2 * d;
    };
    
    ll ANS = f(1) - f(a) - f(b) + f(lcm);
    print(ANS);
    }
    
    signed main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cout << setprecision(15);
    
    ll T = 1;
    // LL(T);
    FOR(T) solve();
    
    return 0;
    }    
}

void abc253(){
    /**
    *    author:  tourist
    *    created: 28.05.2022 16:04:42       
    **/
    #include <bits/stdc++.h>

    using namespace std;

    #ifdef LOCAL
    #include "algo/debug.h"
    #else
    #define debug(...) 42
    #endif

    template <typename T>
    T inverse(T a, T m) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = m / a;
        m -= t * a; swap(a, m);
        u -= t * v; swap(u, v);
    }
    assert(m == 1);
    return u;
    }

    template <typename T>
    class Modular {
    public:
    using Type = typename decay<decltype(T::value)>::type;

    constexpr Modular() : value() {}
    template <typename U>
    Modular(const U& x) {
        value = normalize(x);
    }

    template <typename U>
    static Type normalize(const U& x) {
        Type v;
        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % mod());
        if (v < 0) v += mod();
        return v;
    }

    const Type& operator()() const { return value; }
    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }
    constexpr static Type mod() { return T::value; }

    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }
    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }
    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }
    Modular& operator++() { return *this += 1; }
    Modular& operator--() { return *this -= 1; }
    Modular operator++(int) { Modular result(*this); *this += 1; return result; }
    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }
    Modular operator-() const { return Modular(-value); }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {
    #ifdef _WIN32
        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);
        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;
        asm(
        "divl %4; \n\t"
        : "=a" (d), "=d" (m)
        : "d" (xh), "a" (xl), "r" (mod())
        );
        value = m;
    #else
        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));
    #endif
        return *this;
    }
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {
        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
        value = normalize(value * rhs.value - q * mod());
        return *this;
    }
    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {
        value = normalize(value * rhs.value);
        return *this;
    }

    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }

    friend const Type& abs(const Modular& x) { return x.value; }

    template <typename U>
    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename U>
    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename V, typename U>
    friend V& operator>>(V& stream, Modular<U>& number);

    private:
    Type value;
    };

    template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }
    template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }
    template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }

    template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
    template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }
    template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }

    template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }

    template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
    template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }
    template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }

    template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
    template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
    template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }

    template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
    template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
    template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }

    template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
    template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
    template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }

    template<typename T, typename U>
    Modular<T> power(const Modular<T>& a, const U& b) {
    assert(b >= 0);
    Modular<T> x = a, res = 1;
    U p = b;
    while (p > 0) {
        if (p & 1) res *= x;
        x *= x;
        p >>= 1;
    }
    return res;
    }

    template <typename T>
    bool IsZero(const Modular<T>& number) {
    return number() == 0;
    }

    template <typename T>
    string to_string(const Modular<T>& number) {
    return to_string(number());
    }

    // U == std::ostream? but done this way because of fastoutput
    template <typename U, typename T>
    U& operator<<(U& stream, const Modular<T>& number) {
    return stream << number();
    }

    // U == std::istream? but done this way because of fastinput
    template <typename U, typename T>
    U& operator>>(U& stream, Modular<T>& number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
    }

    /*
    using ModType = int;

    struct VarMod { static ModType value; };
    ModType VarMod::value;
    ModType& md = VarMod::value;
    using Mint = Modular<VarMod>;
    */

    constexpr int md = 998244353;
    using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;

    /*vector<Mint> fact(1, 1);
    vector<Mint> inv_fact(1, 1);

    Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
    }*/

    int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, k;
    cin >> n >> m >> k;
    vector<Mint> f(m, 1);
    for (int it = 1; it < n; it++) {
        vector<Mint> pref(m + 1);
        for (int i = 0; i < m; i++) {
        pref[i + 1] = pref[i] + f[i];
        }
        for (int i = 0; i < m; i++) {
        int L = max(0, i - k + 1);
        int R = min(m - 1, i + k - 1);
        if (k == 0) {
            f[i] = pref[m];
        } else {
            f[i] = pref[m] - (pref[R + 1] - pref[L]);
        }
        }
    }
    cout << accumulate(f.begin(), f.end(), Mint(0)) << '\n';
    return 0;
    }

}

void abc253e(){
    #include<bits/stdc++.h>
    #include<atcoder/all>

    using namespace std;

    using int64 = long long;
    // const int mod = 1e9 + 7;
    const int mod = 998244353;

    const int64 infll = (1LL << 62) - 1;
    const int inf = (1 << 30) - 1;

    struct IoSetup {
    IoSetup() {
        cin.tie(nullptr);
        ios::sync_with_stdio(false);
        cout << fixed << setprecision(10);
        cerr << fixed << setprecision(10);
    }
    } iosetup;


    template< typename T1, typename T2 >
    ostream &operator<<(ostream &os, const pair< T1, T2 > &p) {
    os << p.first << " " << p.second;
    return os;
    }

    template< typename T1, typename T2 >
    istream &operator>>(istream &is, pair< T1, T2 > &p) {
    is >> p.first >> p.second;
    return is;
    }

    template< typename T >
    ostream &operator<<(ostream &os, const vector< T > &v) {
    for(int i = 0; i < (int) v.size(); i++) {
        os << v[i] << (i + 1 != v.size() ? " " : "");
    }
    return os;
    }

    template< typename T >
    istream &operator>>(istream &is, vector< T > &v) {
    for(T &in: v) is >> in;
    return is;
    }

    template< typename T1, typename T2 >
    inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }

    template< typename T1, typename T2 >
    inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }

    template< typename T = int64 >
    vector< T > make_v(size_t a) {
    return vector< T >(a);
    }

    template< typename T, typename... Ts >
    auto make_v(size_t a, Ts... ts) {
    return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));
    }

    template< typename T, typename V >
    typename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {
    t = v;
    }

    template< typename T, typename V >
    typename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {
    for(auto &e: t) fill_v(e, v);
    }

    template< typename F >
    struct FixPoint : F {
    FixPoint(F &&f) : F(forward< F >(f)) {}

    template< typename... Args >
    decltype(auto) operator()(Args &&... args) const {
        return F::operator()(*this, forward< Args >(args)...);
    }
    };

    template< typename F >
    inline decltype(auto) MFP(F &&f) {
    return FixPoint< F >{forward< F >(f)};
    }

    int main() {
      int n, m, k;
      cin >> n >> m >> k;
      using mint = modint998244353;
      vector<mint> dp1(m, 1);
      for (int i = 1; i < n; i++) {
        vector<mint> dp2(m);
        for (int j = 0; j < m; j++) {
          if (k == 0) {
            dp2[0] += dp1[j];
            continue;
          }
          if (j + k < m) { dp2[j + k] += dp1[j]; }
          if (j - k >= 0) {
            dp2[0] += dp1[j];
            if (j - k + 1 < m) dp2[j - k + 1] -= dp1[j];
          }
        }
        for (int j = 1; j < m; j++) {
          dp2[j] += dp2[j - 1];
        }
        dp1 = dp2;
      }
      cout << accumulate(begin(dp1), end(dp1), mint()).val() << endl;
    }
}

abc175d(){

    #include <bits/stdc++.h>
    using namespace std;

    using ll = long long;
    using pii = pair<int, int>;
    template <class T>
    using V = vector<T>;
    template <class T>
    using VV = V<V<T>>;

    #define pb push_back
    #define eb emplace_back
    #define mp make_pair
    #define fi first
    #define se second
    #define rep(i, n) rep2(i, 0, n)
    #define rep2(i, m, n) for (int i = m; i < (n); i++)
    #define per(i, b) per2(i, 0, b)
    #define per2(i, a, b) for (int i = int(b) - 1; i >= int(a); i--)
    #define ALL(c) (c).begin(), (c).end()
    #define SZ(x) ((int)(x).size())

    constexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }

    template <class T, class U>
    void chmin(T& t, const U& u) {
        if (t > u) t = u;
    }
    template <class T, class U>
    void chmax(T& t, const U& u) {
        if (t < u) t = u;
    }

    template <class T, class U>
    ostream& operator<<(ostream& os, const pair<T, U>& p) {
        os << "(" << p.first << "," << p.second << ")";
        return os;
    }

    template <class T>
    ostream& operator<<(ostream& os, const vector<T>& v) {
        os << "{";
        rep(i, v.size()) {
            if (i) os << ",";
            os << v[i];
        }
        os << "}";
        return os;
    }

    #ifdef LOCAL
    void debug_out() { cerr << endl; }
    template <typename Head, typename... Tail>
    void debug_out(Head H, Tail... T) {
        cerr << " " << H;
        debug_out(T...);
    }
    #define debug(...) \
        cerr << __LINE__ << " [" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
    #define dump(x) cerr << __LINE__ << " " << #x << " = " << (x) << endl
    #else
    #define debug(...) (void(0))
    #define dump(x) (void(0))
    #endif

    constexpr ll INF = TEN(18);

    int main() {
        int N, K;
        cin >> N >> K;
        V<int> P(N), C(N);
        rep(i, N) cin >> P[i], --P[i];
        rep(i, N) cin >> C[i];

        ll ans = -INF;

        rep(i, N) {
            int v = i;
            ll cycle_sum = 0;
            int cycle_cnt = 0;

            while (true) {
                cycle_cnt++;
                cycle_sum += C[v];
                v = P[v];
                if (v == i) break;
            }

            ll path = 0;
            int cnt = 0;

            while (true) {
                cnt++;
                path += C[v];

                if (cnt > K) break;

                int num = (K - cnt) / cycle_cnt;
                ll score = path + max(0ll, cycle_sum) * num;
                chmax(ans, score);

                v = P[v];
                if (v == i) break;
            }
        }

        cout << ans << endl;

        return 0;
    }
}

abc253a(){
  #include <bits/stdc++.h>
  using namespace std;

  int main() {
      int a, b, c;
      cin >> a >> b >> c;
      if ((a <= b and b <= c) or (a >= b and b >= c)) {
          cout << "Yes\n";
      } else {
          cout << "No\n";
      }
      return 0;
  }

}

abc253b(){
  #include <bits/stdc++.h>
  using namespace std;

  int main() {
      int h, w;
      cin >> h >> w;
      vector<pair<int, int>> pieces;
      for (int i = 0; i < h; ++i) {
          for (int j = 0; j < w; ++j) {
              char c;
              cin >> c;
              if (c == 'o') {
                  pieces.emplace_back(i, j);
              }
          }
      }
      const auto& [a, b] = pieces[0];
      const auto& [c, d] = pieces[1];
      cout << abs(a - c) + abs(b - d) << '\n';
      return 0;
  }

}

abc253e2(){
  ll n,m,k;cin>>n>>m>>k;
    
  if(k==0){
      cout<<mint(m).pow(n).val()<<endl;
      return 0;
  }
  auto sm=[](vi a){
      vi b=a;
      rep(i,1,(int)b.size()-1){
          b[i] += b[i-1];
      }
      return b;
  };
  vi dp(m+1);
  rep(i,1,m)dp[i]=1;
  vi dps=sm(dp);
  rep(zz,1,n-1){
      vi nx(m+1);
      rep(i,1,m){
          nx[i] += dps[m];
          if(i+k-1<=m)nx[i] -= dps[i+k-1];
          else nx[i] -= dps[m];
          if(i-k>=0)nx[i] += dps[i-k];
      }
      dp=nx;
      dps=sm(dp);
      /*rep(i,0,m){
          cout<<dp[i].val()<<" ";
      }cout<<endl;*/
  }
  cout<<dps[m].val()<<endl;
  
  return 0;
}

abc174c(){
  int a[1000001];
  int K;
  scanf("%d",&K);
  a[1]=7%K;
  for(int i=2;i<=K;i++)a[i]=(a[i-1]*10+7)%K;
  
  for(int i=1;i<=K;i++)if(a[i]==0){
    printf("%d\n",i);
    return 0;
  }
  printf("-1\n");
}

abc253f(){
  #include <bits/stdc++.h>
  #include <atcoder/fenwicktree>
  using namespace std;

  int main() {
    int n, m, q;
    cin >> n >> m >> q;
    vector<int> t(q), a(q), b(q), c(q);
    vector<vector<int>> subt(q);
    vector latest(n, pair(-1, 0));
    vector<long long> ans;
    for (int i = 0; i < q; ++i) {
      cin >> t[i];
      if (t[i] == 1) {
        cin >> a[i] >> b[i] >> c[i];
        a[i] -= 1;
      } else if (t[i] == 2) {
        cin >> a[i] >> b[i];
        a[i] -= 1;
        latest[a[i]] = pair(i, b[i]);
      } else {
        cin >> a[i] >> b[i];
        a[i] -= 1;
        const auto& [j, x] = latest[a[i]];
        const int id = ans.size();
        ans.emplace_back(x);
        c[i] = id;
        if (j >= 0) {
          subt[j].push_back(i);
        }
      }
    }
    atcoder::fenwick_tree<long long> fen(m + 1);
    for (int i = 0; i < q; ++i) {
      if (t[i] == 1) {
        fen.add(a[i], c[i]);
        fen.add(b[i], -c[i]);
      } else if (t[i] == 2) {
        for (const int j : subt[i]) {
          ans[c[j]] -= fen.sum(0, b[j]);
        }
      } else {
        ans[c[i]] += fen.sum(0, b[i]);
      }
    }
    for (const long long x : ans) {
      cout << x << '\n';
    }
    return 0; 
  }
}

abc252c(){
  #include <bits/stdc++.h>
  using namespace std;

  int main(void) {
    int n;
    string s[100];
    int cnt[10][10];
    int ans, mx;
    for (int i = 0; i < 10; i++) {
      for (int j = 0; j < 10; j++)cnt[i][j] = 0;
    }

    cin >> n;
    for (int i = 0; i < n; i++)cin >> s[i];

    for (int i = 0; i < n; i++) {
      for (int j = 0; j < 10; j++) {
        cnt[(s[i][j] - '0')][j]++;
      }
    }

    ans = 1000;
    for (int i = 0; i < 10; i++) {
      mx = 0;
      for (int j = 0; j < 10; j++) {
        mx = max(mx, 10 * (cnt[i][j] - 1) + j);
      }
      ans = min(ans, mx);
    }

    cout << ans << endl;

    return 0;
  }

}

abc252d2(){
  #include<stdio.h>

  int c[200010];
  int main(){
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
      int t;
      scanf("%d",&t);
      c[t]++;
    }
    
    long long ans=0;
    long long small=0;
    for(int i=1;i<=200000;i++){
      ans+=small*c[i]*(n-small-c[i]);
      small+=c[i];
    }
    
    printf("%lld\n",ans);
  }
}

abc252e(){
  #include <bits/stdc++.h>
  using namespace std;

  int main(void) {
    int n;
    priority_queue<long long, vector<long long>, greater<long long> >pq;
    long long x, y, l;
    long long ans = 0;

    cin >> n >> l;
    for (int i = 0; i < n; i++) {
      cin >> x;
      l -= x;
      pq.push(x);
    }

    if (l > 0) {
      pq.push(l);
      n++;
    }
    for (int i = 0; i < (n - 1); i++) {
      x = pq.top();
      pq.pop();
      y = pq.top();
      pq.pop();
      ans += x + y;
      pq.push(x + y);
    }

    cout << ans << endl;
    return 0;
  }

}

abc254d(){
  #include <bits/stdc++.h>
  using namespace std;
  int main(){
    int n;
    cin>>n;
    vector<bool> sq(n+1,false);
    for(int i=1;i*i<=n;i++) sq[i*i]=true;
    vector<vector<int>> d(n+1);
    for(int i=1;i<=n;i++){
      for(int j=i;j<=n;j+=i) d[j].push_back(i);
    }
    vector<int> cnt(n+1);
    for(int i=1;i<=n;i++){
      int f=0;
      for(int j=0;j<d[i].size();j++) if(sq[d[i][j]]) f=d[i][j];
      cnt[i/f]++;
    }
    int ans=0;
    for(int i=1;i<=n;i++) ans+=cnt[i]*cnt[i];
    cout<<ans<<endl;
  }

}

abc254d2(){
  #define ll long long
  int main(){
    int n;
    scanf("%d",&n);
    ll ans=0;
    for(ll i=1;i<=n;i++){
      ll k=i;
      for(ll d=2;d*d<=k;d++){
        while(k%(d*d)==0)k/=d*d;
      }
      for(ll d=1;k*d*d<=n;d++)ans++;
    }
    printf("%lld",ans);
  }

}

abc254e(){
  #include <bits/stdc++.h>
  using namespace std;

  int main() {
      
    int N,M;
    cin>>N>>M;
    vector<vector<int>> E(N);
    for(int i=0;i<M;i++){
      int a,b;
      cin>>a>>b;
      a--,b--;
      E[a].push_back(b);
      E[b].push_back(a);
    }
    
    vector<int> dis(N,-1);
    
    int Q;
    cin>>Q;
    
    for(int i=0;i<Q;i++){
      int x,k;
      cin>>x>>k;
      x--;
      queue<int> q;
      q.push(x);
      dis[x] = 0;
      vector<int> vs;
      while(q.size()>0){
        int u = q.front();
        q.pop();
        vs.push_back(u);
        if(dis[u]==k){
          continue;
        }
        for(int j=0;j<E[u].size();j++){
          int v = E[u][j];
          if(dis[v]!=-1)continue;
          dis[v] = dis[u] + 1;
          q.push(v);
        }
      }
      int ans = 0;
      for(int j=0;j<vs.size();j++){
        ans += vs[j]+1;
        dis[vs[j]] = -1;
      }
      cout<<ans<<endl;
    }
    
      return 0;
  }

}

abc254f(){
  #include <bits/stdc++.h>
  using namespace std;
  int f(int a, int b){
    return gcd(a, b);
  }
  template <typename T>
  struct segment_tree{
    int N;
    vector<T> ST;
    function<T(T, T)> f;
    T E;
    segment_tree(vector<T> A, function<T(T, T)> f, T E): f(f), E(E){
      int n = A.size();
      N = 1;
      while (N < n){
        N *= 2;
      }
      ST = vector<T>(N * 2 - 1, E);
      for (int i = 0; i < n; i++){
        ST[N - 1 + i] = A[i];
      }
      for (int i = N - 2; i >= 0; i--){
        ST[i] = f(ST[i * 2 + 1], ST[i * 2 + 2]);
      }
    }
    T query(int L, int R, int i, int l, int r){
      if (R <= l || r <= L){
        return E;
      } else if (L <= l && r <= R){
        return ST[i];
      } else {
        int m = (l + r) / 2;
        return f(query(L, R, i * 2 + 1, l, m), query(L, R, i * 2 + 2, m, r));
      }
    }
    T query(int L, int R){
      return query(L, R, 0, 0, N);
    }
  };
  int main(){
    int N, Q;
    cin >> N >> Q;
    vector<int> A(N);
    for (int i = 0; i < N; i++){
      cin >> A[i];
    }
    vector<int> B(N);
    for (int i = 0; i < N; i++){
      cin >> B[i];
    }
    vector<int> C(N - 1), D(N - 1);
    for (int i = 0; i < N - 1; i++){
      C[i] = abs(A[i + 1] - A[i]);
      D[i] = abs(B[i + 1] - B[i]);
    }
    segment_tree<int> ST1(C, f, 0);
    segment_tree<int> ST2(D, f, 0);
    for (int i = 0; i < Q; i++){
      int h1, h2, w1, w2;
      cin >> h1 >> h2 >> w1 >> w2;
      h1--;
      w1--;
      int x = ST1.query(h1, h2 - 1);
      int y = ST2.query(w1, w2 - 1);
      cout << gcd(gcd(x, y), A[h1] + B[w1]) << endl;
    }
  }
}

253e(){
  int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, k;
    cin >> n >> m >> k;
    vector<Mint> f(m, 1);
    for (int it = 1; it < n; it++) {
      vector<Mint> pref(m + 1);
      for (int i = 0; i < m; i++) {
        pref[i + 1] = pref[i] + f[i];
      }
      for (int i = 0; i < m; i++) {
        int L = max(0, i - k + 1);
        int R = min(m - 1, i + k - 1);
        if (k == 0) {
          f[i] = pref[m];
        } else {
          f[i] = pref[m] - (pref[R + 1] - pref[L]);
        }
      }
    }
    cout << accumulate(f.begin(), f.end(), Mint(0)) << '\n';
    return 0;
  }
}

abc173c(){
  #include<bits/stdc++.h>
  #define rep(i,a,b) for(int i=a;i<b;i++)
  #define rrep(i,a,b) for(int i=a;i>=b;i--)
  #define fore(i,a) for(auto &i:a)
  #define all(x) (x).begin(),(x).end()
  //#pragma GCC optimize ("-O3")
  using namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }
  typedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;
  template<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }
  template<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }
  //---------------------------------------------------------------------------------------------------
  int H, W, K;
  string c[6];
  string c2[6];
  //---------------------------------------------------------------------------------------------------
  void _main() {
    cin >> H >> W >> K;
    rep(y, 0, H) cin >> c[y];

    int ans = 0;
    rep(mskH, 0, 1 << H) rep(mskW, 0, 1 << W) {
      rep(y, 0, H) c2[y] = c[y];
      rep(y, 0, H) if (mskH & (1 << y)) rep(x, 0, W) c2[y][x] = 'R';
      rep(x, 0, W) if (mskW & (1 << x)) rep(y, 0, H) c2[y][x] = 'R';

      int cnt = 0;
      rep(x, 0, W) rep(y, 0, H) if (c2[y][x] == '#') cnt++;
      if (cnt == K) ans++;
    }
    cout << ans << endl;
  }

}

abc255b{
  #include<bits/stdc++.h>

  using namespace std;

  int main(){
    int n,k;
    cin >> n >> k;
    vector<int> a(k);
    for(auto &nx : a){
      cin >> nx;
      nx--;
    }
    vector<long long> x(n),y(n);
    for(int i=0;i<n;i++){cin >> x[i] >> y[i];}

    long long res=0;
    for(int i=0;i<n;i++){
      long long cres=8e18;
      for(auto &nx : a){
        cres=min(cres,(x[i]-x[nx])*(x[i]-x[nx]) + (y[i]-y[nx])*(y[i]-y[nx]));
      }
      res=max(res,cres);
    }
    printf("%.12lf\n",sqrt((double)res));
    return 0;
  }


}

abc255d{
  #include<bits/stdc++.h>

  using namespace std;

  int main(){
    int n,q;
    cin >> n >> q;
    vector<long long> a(n);
    for(auto &nx : a){cin >> nx;}
    sort(a.begin(),a.end());

    vector<long long> rw(n+1,0);
    for(long long i=0;i<n;i++){rw[i+1]=rw[i]+a[i];}

    for(int i=0;i<q;i++){
      long long x;
      cin >> x;
      int st=0,fi=n-1;
      while(st<=fi){
        int te=(st+fi)/2;
        if(a[te]<x){st=te+1;}
        else{fi=te-1;}
      }
      long long res=x*st;
      res-=rw[fi+1];
      res+=(rw[n]-rw[st]);
      res-=x*(n-st);
      cout << res << '\n';
    }
    return 0;
  }

}

abc255e{
  #include <iostream>
  #include <map>
  using namespace std;
  typedef long long ll;

  ll n, m;
  ll s[200005], x[15];
  ll b[200005];

  int main(void)
  {
    cin >> n >> m;
    for(int i = 1; i <= n-1; i++) cin >> s[i];
    for(int i = 1; i <= m; i++) cin >> x[i];
    
    for(int i = 2; i <= n; i++) b[i] = s[i-1] - b[i-1];
    
    map<ll, ll> mp;
    for(int i = 1; i <= n; i++){
      for(int j = 1; j <= m; j++){
        ll c = x[j] - b[i];
        if(i % 2 == 0) c *= -1;
        mp[c]++;
      }
    }
    
    ll ans = 0;
    for(auto p : mp) ans = max(ans, p.second);
    cout << ans << endl;
    
    return 0;
  }

}

abc254d{
  
  int n;
  cin >> n;
  ll ans = 0;

  REP2(i, 1, n) {
    ll k = i;
    for (ll d = 2; d * d <= k; d++) {
      while (k % (d * d) == 0)
        k /= d * d;
    }
    for (ll d = 1; k * d * d <= n; d++)
      ans++;
  }
  cout << ans << endl;
}