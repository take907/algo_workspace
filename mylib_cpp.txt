abc251e{
  #include <iostream>
  using namespace std;
  typedef long long ll;
  const ll inf = 1e18;

  int n;
  int a[300005];
  ll dp[300005][2];

  int main(void)
  {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    
    ll ans = inf;
    for(int t = 0; t <= 1; t++){
      dp[1][t] = a[1]*t, dp[1][1-t] = inf;
      
      for(int i = 2; i <= n; i++){
        dp[i][0] = dp[i-1][1];
        dp[i][1] = min(dp[i-1][0], dp[i-1][1]) + a[i];
      }
      if(t == 0) ans = min(ans, dp[n][1]);
      if(t == 1) ans = min(ans, min(dp[n][0], dp[n][1]));
    }
    cout << ans << endl;
    
    return 0;
  } 

}

abc251g{
  #include <iostream>
  using namespace std;
  typedef long long ll;
  const ll inf = 1e18;

  ll n, m, q;
  ll x[55], y[55];
  ll u[200005], v[200005];
  ll Q1[55], Q2[55], R[55];

  ll cross(ll p, ll q, ll r, ll s){
    return p*s - q*r;
  }

  int main(void)
  {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> x[i] >> y[i];
    x[n+1] = x[1], y[n+1] = y[1];
    cin >> m;
    for(int i = 1; i <= m; i++) cin >> u[i] >> v[i];
    
    for(int i = 1; i <= n; i++){
      Q1[i] = x[i+1]-x[i], Q2[i] = y[i+1]-y[i], R[i] = -inf;
      for(int j = 1; j <= m; j++){
        R[i] = max(R[i], cross(x[i+1]-x[i], y[i+1]-y[i], x[i]+u[j], y[i]+v[j]));
      }
    }
    
    cin >> q;
    ll a, b;
    for(int k = 1; k <= q; k++){
      cin >> a >> b;
      bool ans = true;
      for(int i = 1; i <= n; i++) if(cross(Q1[i], Q2[i], a, b) < R[i]) ans = false;
      if(ans) cout << "Yes" << "\n";
      else cout << "No" << "\n";
    }
    
    return 0;
  } 

}

abc251f{
  #include <iostream>
  #include <utility>
  #include <queue>
  using namespace std;
  typedef long long ll;
  typedef pair<int, int> P;
  const ll inf = 1e18;

  int n, m;
  vector<int> G[200005];
  bool visited[200005];
  vector<P> T1, T2;

  void dfs(int v)
  {
    visited[v] = true;
    for(auto u : G[v]){
      if(!visited[u]){
        T1.push_back(P(v, u));
        dfs(u);
      }
    }
  }
  void bfs()
  {
    for(int i = 1; i <= n; i++) visited[i] = false;
    queue<int> Q;
    Q.push(1), visited[1] = true;
    
    int v;
    while(Q.size()){
      v = Q.front(), Q.pop();
      for(auto u : G[v]){
        if(!visited[u]){
          T2.push_back(P(v, u));
          visited[u] = true;
          Q.push(u);
        }
      }
    }
  }

  int main(void)
  {
    cin >> n >> m;
    int u, v;
    for(int i = 1; i <= m; i++){
      cin >> u >> v;
      G[u].push_back(v);
      G[v].push_back(u);
    }
    
    dfs(1);
    bfs();
    
    for(auto p : T1) cout << p.first << " " << p.second << "\n";
    for(auto p : T2) cout << p.first << " " << p.second << "\n";
    
    return 0;
  } 

}

void 251B_At_Most_3(){
  int N,W; cin >> N >> W;
  vi A(N+2);
  rep(i,N) cin >> A[i];
  A[N]=A[N+1]=0;
  set<int> st;
  rep(i,N){
    rep2(j,i+1,N+1){
      rep2(k,j+1,N+2){
        int sum = 0;
        sum= A[i]+A[j]+A[k];
        if(sum<=W){
          st.insert(sum);
        }
      }
    }
  }
  int ans = st.size();
  cout << ans << endl;
  return;
} 

void 251D_At_Most_3(){
    int W; cin >> W;
    vi a;
    REP2(i,1,99){
        a.push_back(i);
        a.push_back(i*100);
        a.push_back(i*10000);
    }
    cout << a.size() << endl;
    vector_output(a);
    return;
}

void 251TwoSpanningTree(){

  int N,M;
  cin >> N >> M;
  vi G(200005);
  vb visited(200005);
  vpi T1,T2;

  void dfs(int v){
    visited[v] = true;
    for(auto u: G[v]){
      if(!visited[u]){
        T1.push_back(P(v,u));
        dfs(u);
      }
    }
  }

  void bfs(){
    REP2(i,1,N) visited[i] = false;
    que<int> Q;
    Q.push(1), visited[1] = true;

    int v;
    while(Q.size()){
      v = Q.front(), Q.pop();
      for(auto u: G[v]){
        if(!visited[u]){
          T2.push_back(P(v,u));
          visited[u] = true;
          Q.push(u);
        }
      }
    }
  }

  int u,v;
  REP2(i,1,M){
    cin >> u >> v;
    G[u].push_back(v);
    G[v].push_back(u);
  }
  dfs(1);
  bfs();

  for(auto p: T1) cout << p.first << " " << p.second << endl;
  for(auto p: T2) cout << p.first << " " << p.second << endl;
}

void 249A_Jogging(){
    int A,B,C,D,E,F,X;
    cin >> A >> B >>C >> D >> E >> F >> X;

    int takahashi = 0;
    int aoki = 0;

    rep(i,X){
        int time1 = i%(A+C);
        if(time1<A) takahashi+=B;
        
        int time2 = i%(D+F);
        if(time2<D) aoki+=E;
    }
    if(aoki<takahashi) cout << "Takahashi" << endl;
    else if(aoki == takahashi) cout << "Draw" << endl;
    else cout << "Aoki" << endl;
}

void algo_linked_list(){
    struct Node {
        Node* nex;  // 次がどのノードを指すか
        Node* pre;
        string value;  // ノードに付随している値
        Node(const string& value = "") : nex(NULL), value(value) { }
    };

    // 番兵を表すノード (ここではグローバルに置いておく)
    Node* nil;

    // 連結リストの初期化
    void init() {
        nil = new Node();
        nil->nex = nil; // 初期状態では nil が nil を指すように
        nil->pre = nil;
    }

    // 連結リストへ先頭への要素の挿入
    void insert(Node* v) {
        v->nex = nil->nex;  // v の次を、現在の先頭に
        nil->nex = v;  // 先頭を v に書き換える
    }

    void PushHead(Node* v){
    v->nex = nil->nex;
    v->pre = nil;
    nil->nex = v;
    (v->nex)->pre = v;
    return;
    }

    string PopTail(){
    Node *tail = nil->pre;
    if(tail == nil){
        return "Error";
    }else{
        string ret = tail->value;
        nil->pre = tail->pre;
        (nil->pre)->nex = nil;
        delete tail;

        return ret;
    }
    }

    string erase(){
    Node *front = nil->nex;
    if(front == nil){
        return "Error";
    }else{
        string ret = front->value;
        nil->nex = front->nex;
        delete front;
        return ret;
    }
    }
}

void abc250e(){
    int n;  cin >> n;
  vi a(n),b(n);
  rep(i,n) cin >> a[i];
  rep(i,n) cin >> b[i];
  map<int,int> mp;
  vi ca(n),cb(n),mx(n);

  rep(i,n){
    if(!mp.count(a[i])) mp[a[i]] = mp.size()+1;
    ca[i] = mp.size();
  }  
  
  const int INF = 100100100;
  set<int> st;
  int m=0;
  rep(i,n){
    st.insert(b[i]);
    int x = mp[b[i]];
    if(x==0) x = INF;
    m = max(m,x);
    mx[i] = m;
    cb[i] = st.size();
  }
  int q; cin >> q;
  while(q--){
    int x,y; cin >> x >> y;
    x--,y--;
    if(ca[x]==cb[y] && cb[y]==mx[y]){
      cout << "Yes" << endl;
    }else{
      cout << "No" << endl;
    }
  }
}

void abc249e{
    ll n,p; cin >> n >> p;
    vvl dp(3101,vl(3101));
    vvl sum(3101,vl(3101));
    dp[0][0] = modPow(25,p-2,p)*26ll%p;
    vl ten;
    rep(i,6) ten.push_back(pow(10,i));
    REP2(i,1,n) sum[0][i] = dp[0][0];
    REP2(i,1,n){
        REP2(j,1,n){
        REP2(k,1,4){
            if(i-k-1<0) continue;
            ll x = max(j-ten[k-1]+1,0ll),y = max(j-ten[k]+1,0ll);
            dp[i][j] += (sum[i-k-1][x] -sum[i-k-1][y]+p)*25;
            dp[i][j]%=p;
        }
        sum[i][j+1] = sum[i][j] +dp[i][j];
        sum[i][j+1] %= p;
        }
    }
    ll s = 0;
    rep2(i,1,n) s+=dp[i][n];
    cout << s%p << endl;
    return;
}

void abc249f(){
    int n,k; cin >> n >> k;
  vi t(n+1),y(n+1);

  t[0]=1,y[0]=0;
  REP2(i,1,n){
    cin >> t[i] >> y[i];
  }

  ll ans = numeric_limits<ll>::min(), sum=0;

  max_heap<int> ignore;
  min_heap<int> take;

  for(int i=n;i>=0;--i){
    if(t[i]==1){
      ans = max(ans,y[i]+sum);
      k-=1;
    }else{
      if(y[i] >= 0){
        sum += y[i];
        take.push(y[i]);
      }else{
        ignore.push(y[i]);
      }
    }
    if((int)ignore.size() > k){
      if(ignore.empty()){
        break;
      }
      const int val = ignore.top();
      ignore.pop();
      sum += val;
      take.push(val);
    }
  }
  cout << ans << endl;
  return;
}

void abc247e(){
  ll N,X,Y;
  cin >> N >> X >> Y;  
  vector<int> A(N);

  rep(i,N) cin >> A[i];

  int posX{-1}, posY{-1}, B{-1};

  ll res{};
  rep(i,N){
    if(A[i]==X) posX=i;
    if(A[i]==Y) posY=i;
    if(A[i]<Y or X<A[i]) B=i;
    res += max(0,min(posX,posY)-B);
  }
  cout << res << endl;
} 

void abc246e(){

int N;
int Ax,Ay,Bx,By;
string S[1510];

int dx2[4]={1,1,-1,-1};
int dy2[4]={1,-1,1,-1};

int opt[1510][1510][5];
bool vis[1510][1510][5];

int main() {
    

    cin >> N;

    cin >> Ay >> Ax >> By >> Bx;

    Ax--,Ay--,Bx--,By--;
    rep(y,N) cin >> S[y];

    min_heap<pair<int, tuple<int,int,int>>> que;
    rep(x,N) rep(y,N) rep(dir,5) opt[y][x][dir] = INT_MAX;
    rep(x,N) rep(y,N) rep(dir,5) vis[y][x][dir] = false;

    opt[Ay][Ax][4]=0;
    que.push({0,{Ax,Ay,4}});

    while(!que.empty()){
        int x,y,dir;
        tie(x,y,dir) = que.top().second;
        que.pop();


        if(vis[y][x][dir]) continue;
        vis[y][x][dir]=true;

        if(x == Bx && y == By){
        cout << opt[y][x][dir] << endl;
        return 0;
        }
        rep(d,4){
        int xx = x+dx2[d];
        int yy = y+dy2[d];

        if(0 <=xx && xx < N && 0<= yy && yy < N){
            if(S[yy][xx] == '#') continue;
            if(chmin(opt[yy][xx][d],opt[y][x][dir]+(dir!=d))){
            que.push({opt[yy][xx][d],{xx,yy,d}});
            }
        }
        }
    }
    cout << -1 << endl;
    }
}

void algo_data_structure_linked_list_deque(){

    struct Node {
        Node* nex;  // 次がどのノードを指すか
        Node* pre;  // 前がどのノードを指すか
        string value;  // ノードに付随している値
        Node(const string& value = "") : nex(NULL), value(value) { }
    };

    Node* nil;

    void init() {
        nil = new Node();
        nil->nex = nil; // 初期状態では nil の次が nil を指すように
        nil->pre = nil; // 初期状態では nil の前が nil を指すように
    }

    // 双方向連結リストへ先頭への要素の挿入
    void PushHead(Node* v) {
        v->nex = nil->nex;  // v の次を、元の先頭要素に
        v->pre = nil;   // v の前を nil に
        nil->nex = v;  // nil の次を v に書き換える
        (v->nex)->pre = v;  // 元の先頭要素の前を v にする
        return;
    }

    // 双方向連結リストへ末尾への要素の挿入
    void PushTail(Node* v) {
        v->nex = nil;   // v の次を nil に
        v->pre = nil->pre;  // v の前を、元の末尾ノードに
        nil->pre = v;   // nil の前を v に
        (v->pre)->nex = v;  // 元の末尾ノードの次を v に
        return;
    }

    // 双方向連結リストの先頭にある文字列を返し、その要素を削除する
    string PopHead() {
        Node *head = nil->nex;  // 先頭のノードを取得する
        if(head == nil) {
            // 双方向連結リストが空なら、Error を返す
            return "Error";
        }
        else {
            string ret = head->value;   // 先頭の文字列を返す
            nil->nex = head->nex;   // nil の次を、head の次に
            (nil->nex)->pre = nil;  // 新たな先頭の前を nil に
            delete head;    // メモリを開放する

            return ret;
        }
    }

    // 双方向連結リストの末尾にある文字列を返し、その要素を削除する
    string PopTail() {
        Node *tail = nil->pre;  // 末尾のノードを取得する
        if(tail == nil) {
            // 双方向連結リストが空なら、Error を返す
            return "Error";
        }
        else {
            string ret = tail->value;   // 末尾の文字列を返す
            nil->pre = tail->pre;   // nil の前を、tail の前に
            (nil->pre)->nex = nil;  // 新たな末尾の次を nil に
            delete tail;    // メモリを開放する

            return ret;
        }
    }

    int main() {
        // 連結リストの初期化
        init(); 

        int Q;
        cin >> Q;
        for (int i = 0; i < Q; ++i) {
            int type; cin >> type;

            if(type == 0) {
                string S; cin >> S;
                Node *v = new Node(S);  // ノードを作成する
                PushHead(v);
            }
            else if(type == 1) {
                string S; cin >> S;
                Node *v = new Node(S);  // ノードを作成する
                PushTail(v);
            }
            else if(type == 2) {
                cout << PopHead() << endl;
            }
            else if(type == 3) {
                cout << PopTail() << endl;
            }
        }
    }
}

void abc180b(){
    double manhatten(vd X){
        double res=0;
        rep(i,X.size()) res+=abs(X[i]);
        return res;
    }

    double uklid(vd X){
        double res=0;
        rep(i,X.size()) res += X[i]*X[i];
        return sqrt(res);
    }

    double chebishef(vd X){
        double res=0;
        rep(i,X.size()) chmax(res,abs(X[i]));
        return res;
    }

    int main(){
        int N; cin >> N;
        vd X(N);
        rep(i,N) cin >> X[i];

        cout << fixed << setprecision(15);
        cout << manhatten(X) << endl;
        cout << uklid(X) << endl;
        cout << chebishef(X) << endl;
    }
}

void abc180c(){
    ll N; cin >> N;

    set<ll> st;
    REP2(i,1,sqrt(N)){
        if(N%i==0){
        st.insert(i);
        st.insert(N/i);
        }
    }
    // sort(st.begin(),st.end());
    for(ll v: st){
        cout << v << endl;
    }
}

void abc180e(){
    int n;
  cin >> n;
  vector<int> x(n), y(n), z(n);
  rep(i,n) cin >> x[i] >> y[i] >> z[i];
  int n2 = 1<<n;
  // dp INF initialize
  vector<vector<int>> dp(n2,vector<int>(n,INF));
  //  dist 0 initialize
  vector<vector<int>> dist(n,vector<int>(n));

  rep(i,n)rep(j,n) {
    // two dimension
    // now = x[i]-x[j]
    // two point select
    //  get dist[i][j]
    int now = abs(x[i]-x[j]);
    now += abs(y[i]-y[j]);
    now += max(0, z[j]-z[i]);
    dist[i][j] = now;
  }
  rep(i,n) {
    if (i == 0) continue;
    // update dist from 0
    dp[1<<i][i] = dist[0][i];
  }
  rep(i,n2)rep(j,n) {
    // i no hitei wo migini shift shita mono ga 1
    // 
    if (~i>>j&1) continue;
    rep(k,n) {
      if (i>>k&1) continue;
      chmin(dp[i|1<<k][k], dp[i][j]+dist[j][k]);
    }
  }
  cout << dp[n2-1][0] << endl;
  return 0;
}

void abc180f(){
    const int MX = 305;
    mint c[MX][MX];
    mint dp[MX][MX];
    
    mint f(int n, int m, int l) {
    vector<mint> path(l+1);
    path[1] = 1;
    path[2] = 1;
    for (int i = 3; i <= l; ++i) path[i] = path[i-1]*i;
    vector<mint> cycle(l+1);
    for (int i = 2; i <= l; ++i) cycle[i] = path[i-1];
    rep(i,n+1)rep(j,m+1) dp[i][j] = 0;
    dp[0][0] = 1;
    rep(i,n+1)rep(j,m+1) {
        for (int k = 1; k <= l; ++k) {
        int ni = i+k;
        int nj = j+k-1;
        if (ni > n) break;
        if (nj > m) break;
        dp[ni][nj] += dp[i][j]*c[n-i-1][k-1]*path[k];
        }
        for (int k = 2; k <= l; ++k) {
        int ni = i+k;
        int nj = j+k;
        if (ni > n) break;
        if (nj > m) break;
        dp[ni][nj] += dp[i][j]*c[n-i-1][k-1]*cycle[k];
        }
    }
    return dp[n][m];
    }
    
    int main() {
    c[0][0] = 1;
    rep(i,MX-1) {
        rep(j,i+1) {
        c[i+1][j] += c[i][j];
        c[i+1][j+1] += c[i][j];
        }
    }
    
    int n, m, l;
    cin >> n >> m >> l;
    mint ans = f(n,m,l) - f(n,m,l-1);
    cout << ans.val() << endl;
    return 0;
    }
}

void abc180c(){
  int n;
  cin >> n;
  ll ans = 0;
  for (int a = 1; a <= n; ++a) {
    ans += (n-1)/a;
  }
  cout << ans << endl;
  return 0;
}

void abc252d(){
  int main() {
  int N;
  cin >> N;
  vector< int > A(N);
  cin >> A;
  map< int, int > mp;
  for(auto &a: A) mp[a]++;
  int64 ret = 0;
  int64 a = 0, b = 0;
  for(auto&[_, p]: mp) {
    ret += b * p;
    b += a * p;
    a += p;
  }
  cout << ret << "\n";
}
}

#include<bits/stdc++.h>
using namespace std;
using ll=long long;

struct edge{
	int to,cost,idx;
};

vector<int> dijkstra(int s,vector<vector<edge>>&G){
	vector<ll>dist(G.size(),1LL<<60);
	vector<int>idx(G.size());
	dist[s]=0;
	using P=pair<ll,int>;
	priority_queue<P,vector<P>,greater<P>> pq;
	pq.push({0,s});

	while(!pq.empty()){
		auto[d,v]=pq.top();
		pq.pop();
		if(dist[v]!=d)continue;
		for(auto[vv,c,i]:G[v]){
			if(dist[vv]>dist[v]+c){
				dist[vv]=dist[v]+c;
				pq.push({dist[vv],vv});
				idx[vv]=i;  //  <- index 
			}
		}
	}
	return idx;
}

int main(){
	int N,M;
	cin >> N >> M;
	vector<vector<edge>>G(N);
	for(int i=0;i<M;i++){
		int a,b,c;
		cin >> a >> b >> c;
		G[a-1].push_back({b-1,c,i});
		G[b-1].push_back({a-1,c,i});
	}
	vector<int> idx=dijkstra(0,G);
	for(int i=1;i<N;i++)cout << idx[i]+1 << ' ';
}

void arc141a(){
  #include <bits/stdc++.h>
using namespace std;
int main(){
  vector<long long> ten(18);
  ten[0] = 1;
  for (int i = 0; i < 17; i++){
    ten[i + 1] = ten[i] * 10;
  }

  int T;
  cin >> T;
  for (int i = 0; i < T; i++){
    long long N;
    cin >> N;
    int L = to_string(N).size();
    long long ans = ten[L - 1] - 1;
    for (int j = 1; j < L; j++){
      if (L % j == 0){
        long long q = 0;
        for (int k = 0; k < L / j; k++){
          q += ten[k * j];
        }
        long long p = N / q * q;
        ans = max(ans, p);
      }
    }
    cout << ans << endl;
  }
}
}



void abc253c{
    #include <bits/stdc++.h>
    using namespace std;

    int main() {
        int q;
        cin >> q;
        multiset<int> st;
        while (q--) {
            int t;
            cin >> t;
            if (t == 1) {
                int x;
                cin >> x;
                st.insert(x);
            } else if (t == 2) {
                int x, c;
                cin >> x >> c;
                while (c-- and st.find(x) != st.end()) {
                    st.erase(st.find(x));
                }
            } else {
                cout << *st.rbegin() - *st.begin() << endl;
            }
        }
    }
}

void abc253d(){
    void solve() {
    LL(N, a, b);
    ll g = gcd(a, b);
    ll lcm = a * b / g;
    
    auto f = [&](ll d) -> ll {
        ll n = N / d;
        return n * (n + 1) / 2 * d;
    };
    
    ll ANS = f(1) - f(a) - f(b) + f(lcm);
    print(ANS);
    }
    
    signed main() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cout << setprecision(15);
    
    ll T = 1;
    // LL(T);
    FOR(T) solve();
    
    return 0;
    }    
}

void abc253(){
    /**
    *    author:  tourist
    *    created: 28.05.2022 16:04:42       
    **/
    #include <bits/stdc++.h>

    using namespace std;

    #ifdef LOCAL
    #include "algo/debug.h"
    #else
    #define debug(...) 42
    #endif

    template <typename T>
    T inverse(T a, T m) {
    T u = 0, v = 1;
    while (a != 0) {
        T t = m / a;
        m -= t * a; swap(a, m);
        u -= t * v; swap(u, v);
    }
    assert(m == 1);
    return u;
    }

    template <typename T>
    class Modular {
    public:
    using Type = typename decay<decltype(T::value)>::type;

    constexpr Modular() : value() {}
    template <typename U>
    Modular(const U& x) {
        value = normalize(x);
    }

    template <typename U>
    static Type normalize(const U& x) {
        Type v;
        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);
        else v = static_cast<Type>(x % mod());
        if (v < 0) v += mod();
        return v;
    }

    const Type& operator()() const { return value; }
    template <typename U>
    explicit operator U() const { return static_cast<U>(value); }
    constexpr static Type mod() { return T::value; }

    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }
    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }
    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }
    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }
    Modular& operator++() { return *this += 1; }
    Modular& operator--() { return *this -= 1; }
    Modular operator++(int) { Modular result(*this); *this += 1; return result; }
    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }
    Modular operator-() const { return Modular(-value); }

    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {
    #ifdef _WIN32
        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);
        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;
        asm(
        "divl %4; \n\t"
        : "=a" (d), "=d" (m)
        : "d" (xh), "a" (xl), "r" (mod())
        );
        value = m;
    #else
        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));
    #endif
        return *this;
    }
    template <typename U = T>
    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {
        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());
        value = normalize(value * rhs.value - q * mod());
        return *this;
    }
    template <typename U = T>
    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {
        value = normalize(value * rhs.value);
        return *this;
    }

    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }

    friend const Type& abs(const Modular& x) { return x.value; }

    template <typename U>
    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename U>
    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);

    template <typename V, typename U>
    friend V& operator>>(V& stream, Modular<U>& number);

    private:
    Type value;
    };

    template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }
    template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }
    template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }

    template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }
    template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }
    template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }

    template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }

    template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }
    template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }
    template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }

    template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }
    template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }
    template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }

    template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }
    template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }
    template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }

    template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }
    template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }
    template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }

    template<typename T, typename U>
    Modular<T> power(const Modular<T>& a, const U& b) {
    assert(b >= 0);
    Modular<T> x = a, res = 1;
    U p = b;
    while (p > 0) {
        if (p & 1) res *= x;
        x *= x;
        p >>= 1;
    }
    return res;
    }

    template <typename T>
    bool IsZero(const Modular<T>& number) {
    return number() == 0;
    }

    template <typename T>
    string to_string(const Modular<T>& number) {
    return to_string(number());
    }

    // U == std::ostream? but done this way because of fastoutput
    template <typename U, typename T>
    U& operator<<(U& stream, const Modular<T>& number) {
    return stream << number();
    }

    // U == std::istream? but done this way because of fastinput
    template <typename U, typename T>
    U& operator>>(U& stream, Modular<T>& number) {
    typename common_type<typename Modular<T>::Type, long long>::type x;
    stream >> x;
    number.value = Modular<T>::normalize(x);
    return stream;
    }

    /*
    using ModType = int;

    struct VarMod { static ModType value; };
    ModType VarMod::value;
    ModType& md = VarMod::value;
    using Mint = Modular<VarMod>;
    */

    constexpr int md = 998244353;
    using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;

    /*vector<Mint> fact(1, 1);
    vector<Mint> inv_fact(1, 1);

    Mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
    }*/

    int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, k;
    cin >> n >> m >> k;
    vector<Mint> f(m, 1);
    for (int it = 1; it < n; it++) {
        vector<Mint> pref(m + 1);
        for (int i = 0; i < m; i++) {
        pref[i + 1] = pref[i] + f[i];
        }
        for (int i = 0; i < m; i++) {
        int L = max(0, i - k + 1);
        int R = min(m - 1, i + k - 1);
        if (k == 0) {
            f[i] = pref[m];
        } else {
            f[i] = pref[m] - (pref[R + 1] - pref[L]);
        }
        }
    }
    cout << accumulate(f.begin(), f.end(), Mint(0)) << '\n';
    return 0;
    }

}

void abc253e(){
    #include<bits/stdc++.h>
    #include<atcoder/all>

    using namespace std;

    using int64 = long long;
    // const int mod = 1e9 + 7;
    const int mod = 998244353;

    const int64 infll = (1LL << 62) - 1;
    const int inf = (1 << 30) - 1;

    struct IoSetup {
    IoSetup() {
        cin.tie(nullptr);
        ios::sync_with_stdio(false);
        cout << fixed << setprecision(10);
        cerr << fixed << setprecision(10);
    }
    } iosetup;


    template< typename T1, typename T2 >
    ostream &operator<<(ostream &os, const pair< T1, T2 > &p) {
    os << p.first << " " << p.second;
    return os;
    }

    template< typename T1, typename T2 >
    istream &operator>>(istream &is, pair< T1, T2 > &p) {
    is >> p.first >> p.second;
    return is;
    }

    template< typename T >
    ostream &operator<<(ostream &os, const vector< T > &v) {
    for(int i = 0; i < (int) v.size(); i++) {
        os << v[i] << (i + 1 != v.size() ? " " : "");
    }
    return os;
    }

    template< typename T >
    istream &operator>>(istream &is, vector< T > &v) {
    for(T &in: v) is >> in;
    return is;
    }

    template< typename T1, typename T2 >
    inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }

    template< typename T1, typename T2 >
    inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }

    template< typename T = int64 >
    vector< T > make_v(size_t a) {
    return vector< T >(a);
    }

    template< typename T, typename... Ts >
    auto make_v(size_t a, Ts... ts) {
    return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));
    }

    template< typename T, typename V >
    typename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {
    t = v;
    }

    template< typename T, typename V >
    typename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {
    for(auto &e: t) fill_v(e, v);
    }

    template< typename F >
    struct FixPoint : F {
    FixPoint(F &&f) : F(forward< F >(f)) {}

    template< typename... Args >
    decltype(auto) operator()(Args &&... args) const {
        return F::operator()(*this, forward< Args >(args)...);
    }
    };

    template< typename F >
    inline decltype(auto) MFP(F &&f) {
    return FixPoint< F >{forward< F >(f)};
    }

    int main() {
      int n, m, k;
      using mint = modint998244353;
      vector<mint> dp1(m, 1);
      for (int i = 1; i < n; i++) {
        vector<mint> dp2(m);
        for (int j = 0; j < m; j++) {
          if (k == 0) {
            dp2[0] += dp1[j];
            continue;
          }
          if (j + k < m) { dp2[j + k] += dp1[j]; }
          if (j - k >= 0) {
            dp2[0] += dp1[j];
            if (j - k + 1 < m) dp2[j - k + 1] -= dp1[j];
          }
        }
        for (int j = 1; j < m; j++) {
          dp2[j] += dp2[j - 1];
        }
        dp1 = dp2;
      }
      cout << accumulate(begin(dp1), end(dp1), mint()).val() << endl;
    }
}

abc253e2{
  #include <bits/stdc++.h>
  using namespace std;
  const long long MOD = 998244353;
  int main(){
    int N, M, K;
    cin >> N >> M >> K;
    vector<vector<long long>> dp(N, vector<long long>(M, 0));
    for (int i = 0; i < M; i++){
      dp[0][i] = 1;
    }
    for (int i = 0; i < N - 1; i++){
      vector<long long> S(M + 1);
      S[0] = 0;
      for (int j = 0; j < M; j++){
        S[j + 1] = S[j] + dp[i][j];
        S[j + 1] %= MOD;
      }
      for (int j = 0; j < M; j++){
        dp[i + 1][j] = S[M];
        if (K > 0){
          dp[i + 1][j] -= S[min(j + K, M)] - S[max(j - K + 1, 0)];
        }
        dp[i + 1][j] += MOD;
        dp[i + 1][j] %= MOD;
      }
    }
    long long ans = 0;
    for (int i = 0; i < M; i++){
      ans += dp[N - 1][i];
    }
    ans %= MOD;
    cout << ans << endl;
  }
}

abc175d(){

    #include <bits/stdc++.h>
    using namespace std;

    using ll = long long;
    using pii = pair<int, int>;
    template <class T>
    using V = vector<T>;
    template <class T>
    using VV = V<V<T>>;

    #define pb push_back
    #define eb emplace_back
    #define mp make_pair
    #define fi first
    #define se second
    #define rep(i, n) rep2(i, 0, n)
    #define rep2(i, m, n) for (int i = m; i < (n); i++)
    #define per(i, b) per2(i, 0, b)
    #define per2(i, a, b) for (int i = int(b) - 1; i >= int(a); i--)
    #define ALL(c) (c).begin(), (c).end()
    #define SZ(x) ((int)(x).size())

    constexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }

    template <class T, class U>
    void chmin(T& t, const U& u) {
        if (t > u) t = u;
    }
    template <class T, class U>
    void chmax(T& t, const U& u) {
        if (t < u) t = u;
    }

    template <class T, class U>
    ostream& operator<<(ostream& os, const pair<T, U>& p) {
        os << "(" << p.first << "," << p.second << ")";
        return os;
    }

    template <class T>
    ostream& operator<<(ostream& os, const vector<T>& v) {
        os << "{";
        rep(i, v.size()) {
            if (i) os << ",";
            os << v[i];
        }
        os << "}";
        return os;
    }

    #ifdef LOCAL
    void debug_out() { cerr << endl; }
    template <typename Head, typename... Tail>
    void debug_out(Head H, Tail... T) {
        cerr << " " << H;
        debug_out(T...);
    }
    #define debug(...) \
        cerr << __LINE__ << " [" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
    #define dump(x) cerr << __LINE__ << " " << #x << " = " << (x) << endl
    #else
    #define debug(...) (void(0))
    #define dump(x) (void(0))
    #endif

    constexpr ll INF = TEN(18);

    int main() {
        int N, K;
        cin >> N >> K;
        V<int> P(N), C(N);
        rep(i, N) cin >> P[i], --P[i];
        rep(i, N) cin >> C[i];

        ll ans = -INF;

        rep(i, N) {
            int v = i;
            ll cycle_sum = 0;
            int cycle_cnt = 0;

            while (true) {
                cycle_cnt++;
                cycle_sum += C[v];
                v = P[v];
                if (v == i) break;
            }

            ll path = 0;
            int cnt = 0;

            while (true) {
                cnt++;
                path += C[v];

                if (cnt > K) break;

                int num = (K - cnt) / cycle_cnt;
                ll score = path + max(0ll, cycle_sum) * num;
                chmax(ans, score);

                v = P[v];
                if (v == i) break;
            }
        }

        cout << ans << endl;

        return 0;
    }
}

abc253a(){
  #include <bits/stdc++.h>
  using namespace std;

  int main() {
      int a, b, c;
      cin >> a >> b >> c;
      if ((a <= b and b <= c) or (a >= b and b >= c)) {
          cout << "Yes\n";
      } else {
          cout << "No\n";
      }
      return 0;
  }

}

abc253b(){
  #include <bits/stdc++.h>
  using namespace std;

  int main() {
      int h, w;
      cin >> h >> w;
      vector<pair<int, int>> pieces;
      for (int i = 0; i < h; ++i) {
          for (int j = 0; j < w; ++j) {
              char c;
              cin >> c;
              if (c == 'o') {
                  pieces.emplace_back(i, j);
              }
          }
      }
      const auto& [a, b] = pieces[0];
      const auto& [c, d] = pieces[1];
      cout << abs(a - c) + abs(b - d) << '\n';
      return 0;
  }

}

abc253e2(){
  ll n,m,k;cin>>n>>m>>k;
    
  if(k==0){
      cout<<mint(m).pow(n).val()<<endl;
      return 0;
  }
  auto sm=[](vi a){
      vi b=a;
      rep(i,1,(int)b.size()-1){
          b[i] += b[i-1];
      }
      return b;
  };
  vi dp(m+1);
  rep(i,1,m)dp[i]=1;
  vi dps=sm(dp);
  rep(zz,1,n-1){
      vi nx(m+1);
      rep(i,1,m){
          nx[i] += dps[m];
          if(i+k-1<=m)nx[i] -= dps[i+k-1];
          else nx[i] -= dps[m];
          if(i-k>=0)nx[i] += dps[i-k];
      }
      dp=nx;
      dps=sm(dp);
      /*rep(i,0,m){
          cout<<dp[i].val()<<" ";
      }cout<<endl;*/
  }
  cout<<dps[m].val()<<endl;
  
  return 0;
}

abc174c(){
  int a[1000001];
  int K;
  scanf("%d",&K);
  a[1]=7%K;
  for(int i=2;i<=K;i++)a[i]=(a[i-1]*10+7)%K;
  
  for(int i=1;i<=K;i++)if(a[i]==0){
    printf("%d\n",i);
    return 0;
  }
  printf("-1\n");
}

abc253f(){
  #include <bits/stdc++.h>
  #include <atcoder/fenwicktree>
  using namespace std;

  int main() {
    int n, m, q;
    cin >> n >> m >> q;
    vector<int> t(q), a(q), b(q), c(q);
    vector<vector<int>> subt(q);
    vector latest(n, pair(-1, 0));
    vector<long long> ans;
    for (int i = 0; i < q; ++i) {
      cin >> t[i];
      if (t[i] == 1) {
        cin >> a[i] >> b[i] >> c[i];
        a[i] -= 1;
      } else if (t[i] == 2) {
        cin >> a[i] >> b[i];
        a[i] -= 1;
        latest[a[i]] = pair(i, b[i]);
      } else {
        cin >> a[i] >> b[i];
        a[i] -= 1;
        const auto& [j, x] = latest[a[i]];
        const int id = ans.size();
        ans.emplace_back(x);
        c[i] = id;
        if (j >= 0) {
          subt[j].push_back(i);
        }
      }
    }
    atcoder::fenwick_tree<long long> fen(m + 1);
    for (int i = 0; i < q; ++i) {
      if (t[i] == 1) {
        fen.add(a[i], c[i]);
        fen.add(b[i], -c[i]);
      } else if (t[i] == 2) {
        for (const int j : subt[i]) {
          ans[c[j]] -= fen.sum(0, b[j]);
        }
      } else {
        ans[c[i]] += fen.sum(0, b[i]);
      }
    }
    for (const long long x : ans) {
      cout << x << '\n';
    }
    return 0; 
  }
}

abc252c(){
  #include <bits/stdc++.h>
  using namespace std;

  int main(void) {
    int n;
    string s[100];
    int cnt[10][10];
    int ans, mx;
    for (int i = 0; i < 10; i++) {
      for (int j = 0; j < 10; j++)cnt[i][j] = 0;
    }

    cin >> n;
    for (int i = 0; i < n; i++)cin >> s[i];

    for (int i = 0; i < n; i++) {
      for (int j = 0; j < 10; j++) {
        cnt[(s[i][j] - '0')][j]++;
      }
    }

    ans = 1000;
    for (int i = 0; i < 10; i++) {
      mx = 0;
      for (int j = 0; j < 10; j++) {
        mx = max(mx, 10 * (cnt[i][j] - 1) + j);
      }
      ans = min(ans, mx);
    }

    cout << ans << endl;

    return 0;
  }

}

abc252d2(){
  #include<stdio.h>

  int c[200010];
  int main(){
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
      int t;
      scanf("%d",&t);
      c[t]++;
    }
    
    long long ans=0;
    long long small=0;
    for(int i=1;i<=200000;i++){
      ans+=small*c[i]*(n-small-c[i]);
      small+=c[i];
    }
    
    printf("%lld\n",ans);
  }
}

abc252e(){
  #include <bits/stdc++.h>
  using namespace std;

  int main(void) {
    int n;
    priority_queue<long long, vector<long long>, greater<long long> >pq;
    long long x, y, l;
    long long ans = 0;

    cin >> n >> l;
    for (int i = 0; i < n; i++) {
      cin >> x;
      l -= x;
      pq.push(x);
    }

    if (l > 0) {
      pq.push(l);
      n++;
    }
    for (int i = 0; i < (n - 1); i++) {
      x = pq.top();
      pq.pop();
      y = pq.top();
      pq.pop();
      ans += x + y;
      pq.push(x + y);
    }

    cout << ans << endl;
    return 0;
  }

}

abc254d(){
  #include <bits/stdc++.h>
  using namespace std;
  int main(){
    int n;
    cin>>n;
    vector<bool> sq(n+1,false);
    for(int i=1;i*i<=n;i++) sq[i*i]=true;
    vector<vector<int>> d(n+1);
    for(int i=1;i<=n;i++){
      for(int j=i;j<=n;j+=i) d[j].push_back(i);
    }
    vector<int> cnt(n+1);
    for(int i=1;i<=n;i++){
      int f=0;
      for(int j=0;j<d[i].size();j++) if(sq[d[i][j]]) f=d[i][j];
      cnt[i/f]++;
    }
    int ans=0;
    for(int i=1;i<=n;i++) ans+=cnt[i]*cnt[i];
    cout<<ans<<endl;
  }

}

abc254d2(){
  #define ll long long
  int main(){
    int n;
    scanf("%d",&n);
    ll ans=0;
    for(ll i=1;i<=n;i++){
      ll k=i;
      for(ll d=2;d*d<=k;d++){
        while(k%(d*d)==0)k/=d*d;
      }
      for(ll d=1;k*d*d<=n;d++)ans++;
    }
    printf("%lld",ans);
  }

}

abc254e(){
  #include <bits/stdc++.h>
  using namespace std;

  int main() {
      
    int N,M;
    cin>>N>>M;
    vector<vector<int>> E(N);
    for(int i=0;i<M;i++){
      int a,b;
      cin>>a>>b;
      a--,b--;
      E[a].push_back(b);
      E[b].push_back(a);
    }
    
    vector<int> dis(N,-1);
    
    int Q;
    cin>>Q;
    
    for(int i=0;i<Q;i++){
      int x,k;
      cin>>x>>k;
      x--;
      queue<int> q;
      q.push(x);
      dis[x] = 0;
      vector<int> vs;
      while(q.size()>0){
        int u = q.front();
        q.pop();
        vs.push_back(u);
        if(dis[u]==k){
          continue;
        }
        for(int j=0;j<E[u].size();j++){
          int v = E[u][j];
          if(dis[v]!=-1)continue;
          dis[v] = dis[u] + 1;
          q.push(v);
        }
      }
      int ans = 0;
      for(int j=0;j<vs.size();j++){
        ans += vs[j]+1;
        dis[vs[j]] = -1;
      }
      cout<<ans<<endl;
    }
    
      return 0;
  }

}

abc254f(){
  #include <bits/stdc++.h>
  using namespace std;
  int f(int a, int b){
    return gcd(a, b);
  }
  template <typename T>
  struct segment_tree{
    int N;
    vector<T> ST;
    function<T(T, T)> f;
    T E;
    segment_tree(vector<T> A, function<T(T, T)> f, T E): f(f), E(E){
      int n = A.size();
      N = 1;
      while (N < n){
        N *= 2;
      }
      ST = vector<T>(N * 2 - 1, E);
      for (int i = 0; i < n; i++){
        ST[N - 1 + i] = A[i];
      }
      for (int i = N - 2; i >= 0; i--){
        ST[i] = f(ST[i * 2 + 1], ST[i * 2 + 2]);
      }
    }
    T query(int L, int R, int i, int l, int r){
      if (R <= l || r <= L){
        return E;
      } else if (L <= l && r <= R){
        return ST[i];
      } else {
        int m = (l + r) / 2;
        return f(query(L, R, i * 2 + 1, l, m), query(L, R, i * 2 + 2, m, r));
      }
    }
    T query(int L, int R){
      return query(L, R, 0, 0, N);
    }
  };
  int main(){
    int N, Q;
    cin >> N >> Q;
    vector<int> A(N);
    for (int i = 0; i < N; i++){
      cin >> A[i];
    }
    vector<int> B(N);
    for (int i = 0; i < N; i++){
      cin >> B[i];
    }
    vector<int> C(N - 1), D(N - 1);
    for (int i = 0; i < N - 1; i++){
      C[i] = abs(A[i + 1] - A[i]);
      D[i] = abs(B[i + 1] - B[i]);
    }
    segment_tree<int> ST1(C, f, 0);
    segment_tree<int> ST2(D, f, 0);
    for (int i = 0; i < Q; i++){
      int h1, h2, w1, w2;
      cin >> h1 >> h2 >> w1 >> w2;
      h1--;
      w1--;
      int x = ST1.query(h1, h2 - 1);
      int y = ST2.query(w1, w2 - 1);
      cout << gcd(gcd(x, y), A[h1] + B[w1]) << endl;
    }
  }
}

253e(){
  int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, k;
    cin >> n >> m >> k;
    vector<Mint> f(m, 1);
    for (int it = 1; it < n; it++) {
      vector<Mint> pref(m + 1);
      for (int i = 0; i < m; i++) {
        pref[i + 1] = pref[i] + f[i];
      }
      for (int i = 0; i < m; i++) {
        int L = max(0, i - k + 1);
        int R = min(m - 1, i + k - 1);
        if (k == 0) {
          f[i] = pref[m];
        } else {
          f[i] = pref[m] - (pref[R + 1] - pref[L]);
        }
      }
    }
    cout << accumulate(f.begin(), f.end(), Mint(0)) << '\n';
    return 0;
  }
}

abc173c(){
  #include<bits/stdc++.h>
  #define rep(i,a,b) for(int i=a;i<b;i++)
  #define rrep(i,a,b) for(int i=a;i>=b;i--)
  #define fore(i,a) for(auto &i:a)
  #define all(x) (x).begin(),(x).end()
  //#pragma GCC optimize ("-O3")
  using namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }
  typedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;
  template<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }
  template<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }
  //---------------------------------------------------------------------------------------------------
  int H, W, K;
  string c[6];
  string c2[6];
  //---------------------------------------------------------------------------------------------------
  void _main() {
    cin >> H >> W >> K;
    rep(y, 0, H) cin >> c[y];

    int ans = 0;
    rep(mskH, 0, 1 << H) rep(mskW, 0, 1 << W) {
      rep(y, 0, H) c2[y] = c[y];
      rep(y, 0, H) if (mskH & (1 << y)) rep(x, 0, W) c2[y][x] = 'R';
      rep(x, 0, W) if (mskW & (1 << x)) rep(y, 0, H) c2[y][x] = 'R';

      int cnt = 0;
      rep(x, 0, W) rep(y, 0, H) if (c2[y][x] == '#') cnt++;
      if (cnt == K) ans++;
    }
    cout << ans << endl;
  }

}

abc255b{
  #include<bits/stdc++.h>

  using namespace std;

  int main(){
    int n,k;
    cin >> n >> k;
    vector<int> a(k);
    for(auto &nx : a){
      cin >> nx;
      nx--;
    }
    vector<long long> x(n),y(n);
    for(int i=0;i<n;i++){cin >> x[i] >> y[i];}

    long long res=0;
    for(int i=0;i<n;i++){
      long long cres=8e18;
      for(auto &nx : a){
        cres=min(cres,(x[i]-x[nx])*(x[i]-x[nx]) + (y[i]-y[nx])*(y[i]-y[nx]));
      }
      res=max(res,cres);
    }
    printf("%.12lf\n",sqrt((double)res));
    return 0;
  }


}

abc255d{
  #include<bits/stdc++.h>

  using namespace std;

  int main(){
    int n,q;
    cin >> n >> q;
    vector<long long> a(n);
    for(auto &nx : a){cin >> nx;}
    sort(a.begin(),a.end());

    vector<long long> rw(n+1,0);
    for(long long i=0;i<n;i++){rw[i+1]=rw[i]+a[i];}

    for(int i=0;i<q;i++){
      long long x;
      cin >> x;
      int st=0,fi=n-1;
      while(st<=fi){
        int te=(st+fi)/2;
        if(a[te]<x){st=te+1;}
        else{fi=te-1;}
      }
      long long res=x*st;
      res-=rw[fi+1];
      res+=(rw[n]-rw[st]);
      res-=x*(n-st);
      cout << res << '\n';
    }
    return 0;
  }

}

abc255e{
  #include <iostream>
  #include <map>
  using namespace std;
  typedef long long ll;

  ll n, m;
  ll s[200005], x[15];
  ll b[200005];

  int main(void)
  {
    cin >> n >> m;
    for(int i = 1; i <= n-1; i++) cin >> s[i];
    for(int i = 1; i <= m; i++) cin >> x[i];
    
    for(int i = 2; i <= n; i++) b[i] = s[i-1] - b[i-1];
    
    map<ll, ll> mp;
    for(int i = 1; i <= n; i++){
      for(int j = 1; j <= m; j++){
        ll c = x[j] - b[i];
        if(i % 2 == 0) c *= -1;
        mp[c]++;
      }
    }
    
    ll ans = 0;
    for(auto p : mp) ans = max(ans, p.second);
    cout << ans << endl;
    
    return 0;
  }

}

abc254d{
  
  int n;
  cin >> n;
  ll ans = 0;

  REP2(i, 1, n) {
    ll k = i;
    for (ll d = 2; d * d <= k; d++) {
      while (k % (d * d) == 0)
        k /= d * d;
    }
    for (ll d = 1; k * d * d <= n; d++)
      ans++;
  }
  cout << ans << endl;
}

edu1{
  #include <iostream>
  using namespace std;

  long long N, K, L;
  long long A[1 << 18];

  bool solve(long long M) {
      long long cnt = 0, pre = 0;
      for (int i = 1; i <= N; i++) {
          if (A[i] - pre >= M && L - A[i] >= M) {
              cnt += 1;
              pre = A[i];
          }
      }
      if (cnt >= K) return true;
      return false;
  }

  int main() {
      // Step #1. 入力
      cin >> N >> L;
      cin >> K;
      for (int i = 1; i <= N; i++) {
          cin >> A[i];
      }
      
      // Step #2. 答えで二分探索（めぐる式二分探索法）
      // https://qiita.com/drken/items/97e37dd6143e33a64c8c
      long long left = -1;
      long long right = L + 1;
      while (right - left > 1) {
          long long mid = left + (right - left) / 2;
          if (solve(mid) == false) right = mid;
          else left = mid;
      }
      cout << left << endl;
      return 0;
  }
}

edu2{
  #include <iostream>
  #include <string>
  using namespace std;

  bool hantei(string S) {
    int dep = 0;
    for (int i = 0; i < S.size(); i++) {
      if (S[i] == '(') dep += 1;
      if (S[i] == ')') dep -= 1;
      if (dep < 0) return false;
    }
    if (dep == 0) return true;
    return false;
  }

  int main() {
    int N;
    cin >> N;
    for (int i = 0; i < (1 << N); i++) {
      string Candidate = "";
      for (int j = N - 1; j >= 0; j--) {
        // メモ : (i & (1 << j)) = 0 というのは、i の j ビット目（2^j の位）が 0 であるための条件。
        // 　　　頻出なので知っておくようにしましょう。
        if ((i & (1 << j)) == 0) {
          Candidate += "(";
        }
        else {
          Candidate += ")";
        }
      }
      bool I = hantei(Candidate);
      if (I == true) cout << Candidate << endl;
    }
    return 0;
  }
}

edu3{
  #include <iostream>
  #include <vector>
  #include <queue>
  using namespace std;

  // 入力
  int N;
  int A[1 << 18], B[1 << 18];

  // グラフ
  const int INF = (1 << 29);
  vector<int> G[1 << 18];
  int dist[1 << 18];

  void getdist(int start) {
    // 幅優先探索（BFS）により、最短距離を計算
    for (int i = 1; i <= N; i++) dist[i] = INF;

    queue<int> Q;
    Q.push(start);
    dist[start] = 0;

    while (!Q.empty()) {
      int pos = Q.front(); Q.pop();
      for (int to : G[pos]) {
        if (dist[to] == INF) {
          dist[to] = dist[pos] + 1;
          Q.push(to);
        }
      }
    }
  }

  int main() {
    // Step #1. 入力
    cin >> N;
    for (int i = 1; i <= N - 1; i++) {
      cin >> A[i] >> B[i];
      G[A[i]].push_back(B[i]);
      G[B[i]].push_back(A[i]);
    }

    // Step #2. 頂点 1 からの最短距離を求める
    // maxid1: 頂点 1 から最も離れている（最短距離が長い）頂点
    getdist(1);
    int maxn1 = -1, maxid1 = -1;
    for (int i = 1; i <= N; i++) {
      if (maxn1 < dist[i]) {
        maxn1 = dist[i];
        maxid1 = i;
      }
    }

    // Step #3. 頂点 maxid1 からの最短距離を求める
    // maxn2: 木の直径（最短距離の最大値）
    getdist(maxid1);
    int maxn2 = -1;
    for (int i = 1; i <= N; i++) {
      maxn2 = max(maxn2, dist[i]);
    }

    // Step #4. 出力
    cout << maxn2 + 1 << endl;
    return 0;
  }
}

edu4{
  int h, w;
  cin >> h >> w;
  vvi A(h, vi(w));
  cin >> A;
  vvi B(h, vi(w, 0));
  vi row_sum(h);
  rep(i, h) {
    rep(j, w) {
      row_sum[i] += A[i][j];
    }
  }
  vi col_sum(w);
  rep(i, w) {
    rep(j, h) {
      col_sum[i] += A[j][i];
    }
  }
  rep(i, h) {
    rep(j, w) {
      B[i][j] = row_sum[i] + col_sum[j] - A[i][j];
      cout << B[i][j] << " \n"[j == w - 1];
    }
  }
}

edu5{
  #include <iostream>
  using namespace std;

  long long modpow(long long a, long long b, long long m) {
    long long p = 1, q = a;
    for (int i = 0; i < 63; i++) {
      if ((b & (1LL << i)) != 0) {
        p *= q;
        p %= m;
      }
      q *= q;
      q %= m;
    }
    return p;
  }

  const long long mod = 1000000007;

  // 入力
  long long N, B, K;
  long long C[11];

  // その他の変数
  long long power10[64];
  long long DP[64][1009];
  long long Answer[64][1009];

  int main() {
    // Step #1. 入力
    cin >> N >> B >> K;
    for (int i = 1; i <= K; i++) cin >> C[i];
    
    // Step #2. 前計算
    for (int i = 0; i <= 62; i++) {
      power10[i] = modpow(10LL, (1LL << i), B);
    }
    
    // Step #3. dp[1][i] を求める
    for (int i = 1; i <= K; i++) {
      DP[0][C[i] % B] += 1;
    }

    // Step #4. dp[1][i], dp[2][i], ..., dp[2^n][i] を求める
    for (int i = 0; i < 62; i++) {
      for (int j = 0; j < B; j++) {
        for (int k = 0; k < B; k++) {
          int nex = (j * power10[i] + k) % B;
          DP[i + 1][nex] += DP[i][j] * DP[i][k];
          DP[i + 1][nex] %= mod;
        }
      }
    }

    // Step #5. 繰り返し二乗法により dp[N][i] を求める
    Answer[0][0] = 1;
    for (int i = 0; i < 62; i++) {
      if ((N & (1LL << i)) != 0LL) {
        for (int j = 0; j < B; j++) {
          for (int k = 0; k < B; k++) {
            int nex = (j * power10[i] + k) % B;
            Answer[i + 1][nex] += Answer[i][j] * DP[i][k];
            Answer[i + 1][nex] %= mod;
          }
        }
      }
      else {
        for (int j = 0; j < B; j++) Answer[i + 1][j] = Answer[i][j];
      }
    }

    // Step #6. 出力
    cout << Answer[62][0] << endl;
    return 0;
  }
}

edu6{
  #include <iostream>
  using namespace std;

  string S;
  int N,K;
  int nex[100009][26];

  int main() {
    // Step #1. 入力
    cin >> N >> K;
    cin >> S;

    // Step #2. 前計算
    for (int i = 0; i < 26; i++) nex[S.size()][i] = S.size();
    for (int i = (int)S.size() - 1; i >= 0; i--) {
      for (int j = 0; j < 26; j++) {
        if ((int)(S[i] - 'a') == j) {
          nex[i][j] = i;
        }
        else {
          nex[i][j] = nex[i + 1][j];
        }
      }
    }

    // Step #3. 一文字ずつ貪欲に決める
    string Answer = "";
    int CurrentPos = 0;
    for (int i = 1; i <= K; i++) {
      for (int j = 0; j < 26; j++) {
        int NexPos = nex[CurrentPos][j];
        int MaxPossibleLength = (int)(S.size() - NexPos - 1) + i;
        if (MaxPossibleLength >= K) {
          Answer += (char)('a' + j);
          CurrentPos = NexPos + 1;
          break;
        }
      }
    }

    // Step #4. 出力
    cout << Answer << endl;
    return 0;
  }
}

edu7{
  #include <iostream>
  #include <algorithm>
  #include <cmath>
  using namespace std;

  const int INF = 2000000000;
  int N;
  int A[300009];
  int Q;
  int B[300009];

  int main() {
    // Step #1. Input
    cin >> N;
    for (int i = 1; i <= N; i++) cin >> A[i];
    cin >> Q;
    for (int i = 1; i <= Q; i++) cin >> B[i];

    // Step #2. Sorting
    sort(A + 1, A + N + 1);

    // Step #3. Binary Search
    for (int i = 1; i <= Q; i++) {
      int pos1 = lower_bound(A + 1, A + N + 1, B[i]) - A;
      int Diff1 = INF, Diff2 = INF;
      if (pos1 <= N) Diff1 = abs(B[i] - A[pos1]);
      if (pos1 >= 2) Diff2 = abs(B[i] - A[pos1 - 1]);
      cout << min(Diff1, Diff2) << endl;
    }
    return 0;
  }
}

abc8{
  #include <iostream>
  using namespace std;

  string S;
  long long mod = 1000000007;
  long long dp[100009][8];

  int main() {
    // Step #1. Input
    int N;
    cin >> N;
    cin >> S;

    // Step #2. Dynamic Programming (DP)
    dp[0][0] = 1;
    for (int i = 0; i < (int)S.size(); i++) {
      for (int j = 0; j <= 7; j++) {
        dp[i + 1][j] += dp[i][j];
        if (S[i] == 'a' && j == 0) dp[i + 1][j + 1] += dp[i][j];
        if (S[i] == 't' && j == 1) dp[i + 1][j + 1] += dp[i][j];
        if (S[i] == 'c' && j == 2) dp[i + 1][j + 1] += dp[i][j];
        if (S[i] == 'o' && j == 3) dp[i + 1][j + 1] += dp[i][j];
        if (S[i] == 'd' && j == 4) dp[i + 1][j + 1] += dp[i][j];
        if (S[i] == 'e' && j == 5) dp[i + 1][j + 1] += dp[i][j];
        if (S[i] == 'r' && j == 6) dp[i + 1][j + 1] += dp[i][j];
      }
      for (int j = 0; j <= 7; j++) dp[i + 1][j] %= mod;
    }

    // Step #3. Output the answer
    cout << dp[S.size()][7] << endl;
    return 0;
  }
}

edu9{
  #include <iostream>
  #include <cmath>
  #include <vector>
  #include <algorithm>
  using namespace std;

  struct Point {
    double px, py;
  };

  Point operator-(const Point& a1, const Point& a2) {
    return Point{ a1.px - a2.px, a1.py - a2.py };
  }

  double getangle(Point G) {
    // 点 G の偏角を求める
    if (G.py >= 0.0) {
      double I = G.px / sqrt(G.px * G.px + G.py * G.py);
      double kaku = acos(I) * 180.0 / 3.14159265358979;
      return kaku;
    }
    else {
      double I = G.px / sqrt(G.px * G.px + G.py * G.py);
      double kaku = acos(I) * 180.0 / 3.14159265358979;
      return 360.0 - kaku;
    }
  }

  double getangle2(double I1, double I2) {
    // [偏角 I1] - [原点] - [偏角 I2] のなす角度を求める
    // 例えば I1 = 240°、I2 = 30°のとき、求める角度は 150°
    double res = abs(I1 - I2);
    if (res >= 180.0) return 360.0 - res;
    return res;
  }

  int N;
  Point G[2009];

  double solve(int pos) {
    // 最初に偏角の昇順にソートする
    vector<double> vec;
    for (int i = 1; i <= N; i++) {
      if (i == pos) continue;
      Point SA = G[i] - G[pos];
      double angle = getangle(SA);
      vec.push_back(angle);
    }
    sort(vec.begin(), vec.end());

    // 点 A を全探索して、最も偏角の大きくなる点 C を二分探索（std::lower_bound）で求める
    double ret = 0.0;
    for (int i = 0; i < vec.size(); i++) {
      double target = vec[i] + 180.0;
      if (target >= 360.0) target -= 360.0;
      int pos1 = lower_bound(vec.begin(), vec.end(), target) - vec.begin();

      // 点 C の候補は高々 2 つに絞れる
      int CandIdx1 = pos1 % vec.size();
      int CandIdx2 = (pos1 + vec.size() - 1) % vec.size();
      double Candidate1 = getangle2(vec[i], vec[CandIdx1]);
      double Candidate2 = getangle2(vec[i], vec[CandIdx2]);
      ret = max({ ret, Candidate1, Candidate2 });
    }
    return ret;
  }

  // O(N^3) のアルゴリズム（点 A, B, C を全探索）
  double solve_Slow() {
    double Answer = 0.0;
    for (int i = 1; i <= N; i++) {
      for (int j = 1; j <= N; j++) {
        for (int k = 1; k <= N; k++) {
          if (i == j || i == k || j == k) continue;
          double I1 = getangle(G[i] - G[j]);
          double I2 = getangle(G[k] - G[j]);
          Answer = max(Answer, getangle2(I1, I2));
        }
      }
    }
    return Answer;
  }

  // O(N^2 log N) のアルゴリズム
  double solve_Fast() {
    // 点 B を全探索
    double Answer = 0.0;
    for (int i = 1; i <= N; i++) {
      double ret = solve(i);
      Answer = max(Answer, ret);
    }
    return Answer;
  }

  int main() {
    // Step #1. 入力
    cin >> N;
    for (int i = 1; i <= N; i++) {
      cin >> G[i].px >> G[i].py;
    }

    // Step #2. 出力
    double FinalAns = solve_Fast();
    printf("%.12lf\n", FinalAns);
    return 0;
  }
}

edu10{
  #include <iostream>
  using namespace std;

  // 入力
  int N;
  int C[100009], P[100009];
  int Q;
  int L[100009], R[100009];

  // 累積和
  int Sum1[100009];
  int Sum2[100009];

  int main() {
    // Step #1. 入力
    cin >> N;
    for (int i = 1; i <= N; i++) cin >> C[i] >> P[i];
    cin >> Q;
    for (int i = 1; i <= Q; i++) cin >> L[i] >> R[i];

    // Step #2. 1 組・2 組それぞれの累積和を取る
    for (int i = 1; i <= N; i++) {
      Sum1[i] = Sum1[i - 1];
      Sum2[i] = Sum2[i - 1];
      if (C[i] == 1) Sum1[i] += P[i];
      if (C[i] == 2) Sum2[i] += P[i];
    }

    // Step #3. クエリに答える
    for (int i = 1; i <= Q; i++) {
      int Answer1 = Sum1[R[i]] - Sum1[L[i] - 1];
      int Answer2 = Sum2[R[i]] - Sum2[L[i] - 1];
      cout << Answer1 << " " << Answer2 << endl;
    }
    return 0;
  }
}

abc256e{
  #include <iostream>
  #include <vector>
  using namespace std;

  #include "atcoder/dsu.hpp"

  int main() {
    int N;
    cin >> N;
    vector<int> X(N), C(N);
    for (auto& x : X) cin >> x, --x;
    for (auto& x : C) cin >> x;
    atcoder::dsu uf(N);
    long long ans = 0;
    for (int i = 0; i < N; i++) {
      if (uf.same(i, X[i]) == false) {
        uf.merge(i, X[i]);
        continue;
      }
      int cur = C[i], v = i;
      do {
        v = X[v];
        cur = min(cur, C[v]);
      } while (v != i);
      ans += cur;
    }
    cout << ans << "\n";
  }

}

abc256f{
  #include<bits/stdc++.h>
  #include<atcoder/all>
  using namespace std;
  using namespace atcoder;
  using mint=modint998244353;

  using S=array<mint,3>;
  S e(){return S();}
  S op(S x,S y){return {x[0]+y[0],x[1]+y[1],x[2]+y[2]};}

  int main(){
    int n,q;
    cin >> n >> q;
    vector<S>a(n);
    for(int i=0;i<n;i++){
      int t;
      cin >> t;
      a[i]={mint(t),mint(t)*i,mint(t)*i*i};
    }
    
    segtree<S,op,e>seg(a);
    
    while(q--){
      int t,x;
      cin >> t >> x;
      x--;
      if(t==1){
        int y;
        cin >> y;
        seg.set(x,{mint(y),mint(y)*x,mint(y)*x*x});
      }else{
        S ret=seg.prod(0,x+1);
        cout << (ret[2]/2-ret[1]*(2*x+3)/2+ret[0]*(x+1)*(x+2)/2).val() << endl;
      }
    }
  }

}

aclj{
  #include <atcoder/segtree>
  #include <cstdio>
  #include <vector>

  using namespace std;
  using namespace atcoder;

  int op(int a, int b) { return max(a, b); }

  int e() { return -1; }

  int target;

  bool f(int v) { return v < target; }

  int main() {
      int n, q;
      scanf("%d %d", &n, &q);
      vector<int> a(n);
      for (int i = 0; i < n; i++) {
          scanf("%d", &(a[i]));
      }

      segtree<int, op, e> seg(a);

      for (int i = 0; i < q; i++) {
          int t;
          scanf("%d", &t);
          if (t == 1) {
              int x, v;
              scanf("%d %d", &x, &v);
              x--;
              seg.set(x, v);
          } else if (t == 2) {
              int l, r;
              scanf("%d %d", &l, &r);
              l--;
              printf("%d\n", seg.prod(l, r));
          } else if (t == 3) {
              int p;
              scanf("%d %d", &p, &target);
              p--;
              printf("%d\n", seg.max_right<f>(p) + 1);
          }
      }
  }
}

abc256d{
  #include<stdio.h>

  int a[200010];
  int main(){
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++){
      int l,r;
      scanf("%d%d",&l,&r);
      a[l]++;
      a[r]--;
    }
    for(int i=1;i<=200005;i++)a[i]+=a[i-1];
    for(int i=1;i<=200005;i++){
      if(a[i-1]==0&&a[i]!=0)printf("%d ",i);
      if(a[i-1]!=0&&a[i]==0)printf("%d\n",i);
    }
  }
}

abc256f2{
  #include <bits/stdc++.h>
  #include <atcoder/all>
  using namespace std;
  using namespace atcoder;
  using ll=long long;
  const ll mod=998244353;
  #define rep(i,a) for (ll i=0;i<a;i++)


  ll R=(mod+1)/2;
  struct lazy_S {
      ll E;
      ll F;
      ll size;
  };

  using lazy_F = ll;

  lazy_S lazy_op(lazy_S l, lazy_S r) {
      return lazy_S{
          (l.E+r.E+(l.F*r.size)%mod)%mod,(l.F+r.F)%mod,l.size+r.size
      };
  }

  lazy_S lazy_e() { return lazy_S{0, 0, 0}; }

  lazy_S mapping(lazy_F l, lazy_S r) {
      l%=mod;
      if(l==0) return r;
      ll tmp=(r.size*(r.size+1))%mod;
      tmp*=(l*R)%mod;
      tmp%=mod;
      return lazy_S{
          (r.E+tmp)%mod,(r.F+(l*r.size)%mod)%mod,r.size
      };
  }

  //l(r(x))
  lazy_F composition(lazy_F l, lazy_F r) {
      return (l+r)%mod;
  }

  lazy_F lazy_id(){return 0;}

  #define lazy_calc lazy_S,lazy_op,lazy_e,lazy_F,mapping,composition,lazy_id


  void solve();
  // oddloop
  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      
      int t=1;
      //cin>>t;
      rep(i,t) solve();
  }

  void solve(){
      int N,Q;
      cin>>N>>Q;
      lazy_segtree<lazy_calc> seg(N);
      vector<ll> A(N);
      rep(i,N) seg.set(i,{0,0,1});
      rep(i,N){
          ll a;
          cin>>a;
          A[i]=a;
          seg.apply(i,N,a);
      }
      rep(i,Q){
          int t;
          cin>>t;
          if(t==1){
              ll x,v;
              cin>>x>>v;
              x--;
              seg.apply(x,N,v-A[x]);
              A[x]=v;
          }else{
              ll x;
              cin>>x;
              cout<<(mod+seg.prod(0,x).E)%mod<<"\n";
          }
      }
  }



}

abc255c{
  #include<bits/stdc++.h>

  using namespace std;

  int main(){
    long long x,a,d,n;
    cin >> x >> a >> d >> n;

    if(d<0){
      long long fi=a+d*(n-1);
      a=fi;
      d*=-1;
    }

    long long st=0,fi=(n-1);
    while(st<=fi){
      long long te=(st+fi)/2;
      if((a+d*te)<x){st=te+1;}
      else{fi=te-1;}
    }
    long long res=8e18;
    for(long long i=max(0ll,st-5);i<=min((n-1),st+5);i++){
      res=min(abs(a+d*i-x),res);
    }
    cout << res << '\n';
    return 0;
  }

}

abc171b{
  int N, K, p[1010];
  //---------------------------------------------------------------------------------------------------
  void _main() {
      cin >> N >> K;
      rep(i, 0, N) cin >> p[i];

      int ans = 0;
      sort(p, p + N);
      rep(i, 0, K) ans += p[i];
      cout << ans << endl;
  }
}

abc171c{
  #include <bits/stdc++.h>
  using namespace std;

  int main() {
      long long N;
      cin >> N;
      string res = "";
      while (N) {
          --N;
          res += (char)('a' + (N % 26));
          N /= 26;
      }
      reverse(res.begin(), res.end());
      cout << res << endl;
  }
}

abc256d{
  int main() {
    int n;
    cin >> n;
    vpi kukan;
    rep(i, n) {
      int l, r;
      cin >> l >> r;
      kukan.push_back({l, r});
    }
    sort(all(kukan));
    vpi ans;
    rep(i, n) {
      int left = kukan[i].first;
      int right = kukan[i].second;
      int index = i + 1;
      while (index < n && kukan[index].first <= right) {
        right = max(kukan[index].second, right);
        i = index;
        index++;
      }
      ans.push_back({left, right});
    }
    for (auto [l, r] : ans) {
      cout << l << " " << r << endl;
    }
  }
}

abc255f{
  #include <iostream>
  using namespace std;

  int n;
  int P[200005], I[200005], Iinv[200005];
  int L[200005], R[200005];

  bool solve(int s, int t, int S, int T)
  {
    int r = P[s], p = Iinv[r];
    if(p < S || T < p) return false;

    if(p-S > 0){
      L[r] = P[s+1];
      if(!solve(s+1, s+p-S, S, p-1)) return false;
    }
    if(T-p > 0){
      R[r] = P[s+p-S+1];
      if(!solve(s+p-S+1, t, p+1, T)) return false;
    }
    return true;
  }

  int main(void)
  {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> P[i];
    for(int i = 1; i <= n; i++) cin >> I[i];
    for(int i = 1; i <= n; i++) Iinv[I[i]] = i;

    if(P[1] != 1 || !solve(1, n, 1, n)){
      cout << -1 << endl;
      return 0;
    }
    for(int i = 1; i <= n; i++) cout << L[i] << " " << R[i] << endl;

    return 0;
  }

}

abc170d{
  const int MA = 1000001;
  int N, A[201010];
  int cnt[1010101];
  bool ok[1010101];
  //---------------------------------------------------------------------------------------------------
  void _main() {
      cin >> N;
      rep(i, 0, N) cin >> A[i];

      rep(i, 0, N) cnt[A[i]]++;
      rep(x, 1, MA) ok[x] = true;
      rep(x, 1, MA) if(0 < cnt[x]) {
          if (1 < cnt[x]) ok[x] = false;
          for (int x2 = x * 2; x2 < MA; x2 += x) ok[x2] = false;
      }

      int ans = 0;
      rep(i, 0, N) if (ok[A[i]]) ans++;
      cout << ans << endl;
  }
}

abc170e{
  #include<bits/stdc++.h>
  #define rep(i,a,b) for(int i=a;i<b;i++)
  #define rrep(i,a,b) for(int i=a;i>=b;i--)
  #define fore(i,a) for(auto &i:a)
  #define all(x) (x).begin(),(x).end()
  //#pragma GCC optimize ("-O3")
  using namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }
  typedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;
  template<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }
  template<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }
  //---------------------------------------------------------------------------------------------------
  #define def inf
  template<class V, int NV> struct SegTree { //[l,r)
      V comp(V& l, V& r) { return min(l, r); };

      vector<V> val; SegTree() { val = vector<V>(NV * 2, def); }
      V get(int x, int y, int l = 0, int r = NV, int k = 1) {
          if (r <= x || y <= l)return def; if (x <= l && r <= y)return val[k];
          auto a = get(x, y, l, (l + r) / 2, k * 2);
          auto b = get(x, y, (l + r) / 2, r, k * 2 + 1);
          return comp(a, b);
      }
      void update(int i, V v) {
          i += NV; val[i] = v;
          while (i > 1) i >>= 1, val[i] = comp(val[i * 2], val[i * 2 + 1]);
      }
      void add(int i, V v) { update(i, val[i + NV] + v); }
      V operator[](int x) { return get(x, x + 1); }
  };

  int N, Q, A[201010], B[201010];
  SegTree<int, 1 << 18> st;
  multiset<int> rates[201010];
  int cnt[201010];
  //---------------------------------------------------------------------------------------------------
  void add(int child, int to) {
      cnt[to]++;
      rates[to].insert(A[child]);
      st.update(to, *rates[to].rbegin());
  }
  void erase(int child, int from) {
      cnt[from]--;
      auto ite = rates[from].find(A[child]);
      rates[from].erase(ite);

      if (cnt[from] == 0) st.update(from, inf);
      else st.update(from, *rates[from].rbegin());
  }
  //---------------------------------------------------------------------------------------------------
  void _main() {
      cin >> N >> Q;
      rep(i, 1, N + 1) {
          cin >> A[i] >> B[i];
          add(i, B[i]);
      }

      rep(_, 0, Q) {
          int C, D; cin >> C >> D;
          erase(C, B[C]);
          B[C] = D;
          add(C, B[C]);

          int ans = st.get(0, 201010);
          printf("%d\n", ans);
      }
  }

}

algo_logic_segtree{
  /* RMQ：[0,n-1] について、区間ごとの最小値を管理する構造体
    update(i,x): i 番目の要素を x に更新。O(log(n))
    query(a,b): [a,b) での最小の要素を取得。O(log(n))
  */
  template <typename T>
  struct RMQ {
      const T INF = numeric_limits<T>::max();
      int n;         // 葉の数
      vector<T> dat; // 完全二分木の配列
      RMQ(int n_) : n(), dat(n_ * 4, INF) { // 葉の数は 2^x の形
          int x = 1;
          while (n_ > x) {
              x *= 2;
          }
          n = x;
      }
      void update(int i, T x) {
          i += n - 1;
          dat[i] = x;
          while (i > 0) {
              i = (i - 1) / 2;  // parent
              dat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);
          }
      }
      // the minimum element of [a,b)
      T query(int a, int b) { return query_sub(a, b, 0, 0, n); }
      T query_sub(int a, int b, int k, int l, int r) {
          if (r <= a || b <= l) {
              return INF;
          } else if (a <= l && r <= b) {
              return dat[k];
          } else {
              T vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
              T vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
              return min(vl, vr);
          }
      }
  };
}


algo_logic_segtree2{
  /* RMQ：[0,n-1] について、区間ごとの最小値を管理する構造体
    update(a,b,x): 区間[a,b) の要素を x に更新。O(log(n))
    query(a,b): [a,b) での最小の要素を取得。O(log(n))
  */
  template <typename T>
  struct RMQ {
      const T INF = numeric_limits<T>::max();
      int n;
      vector<T> dat, lazy;
      RMQ(int n_) : n(), dat(n_ * 4, INF), lazy(n_ * 4, INF) {
          int x = 1;
          while (n_ > x) x *= 2;
          n = x;
      }

      /* lazy eval */
      void eval(int k) {
          if (lazy[k] == INF) return;  // 更新するものが無ければ終了
          if (k < n - 1) {             // 葉でなければ子に伝搬
              lazy[k * 2 + 1] = lazy[k];
              lazy[k * 2 + 2] = lazy[k];
          }
          // 自身を更新
          dat[k] = lazy[k];
          lazy[k] = INF;
      }

      void update(int a, int b, T x, int k, int l, int r) {
          eval(k);
          if (a <= l && r <= b) {  // 完全に内側の時
              lazy[k] = x;
              eval(k);
          } else if (a < r && l < b) {                     // 一部区間が被る時
              update(a, b, x, k * 2 + 1, l, (l + r) / 2);  // 左の子
              update(a, b, x, k * 2 + 2, (l + r) / 2, r);  // 右の子
              dat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);
          }
      }
      void update(int a, int b, T x) { update(a, b, x, 0, 0, n); }

      T query_sub(int a, int b, int k, int l, int r) {
          eval(k);
          if (r <= a || b <= l) {  // 完全に外側の時
              return INF;
          } else if (a <= l && r <= b) {  // 完全に内側の時
              return dat[k];
          } else {  // 一部区間が被る時
              T vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
              T vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
              return min(vl, vr);
          }
      }
      T query(int a, int b) { return query_sub(a, b, 0, 0, n); }

      /* debug */
      inline T operator[](int a) { return query(a, a + 1); }
      void print() {
          for (int i = 0; i < 2 * n - 1; ++i) {
              cout << (*this)[i];
              if (i != n) cout << ",";
          }
          cout << endl;
      }
  };
}

algo_logic_segtree3{
  /* RMQ：[0,n-1] について、区間ごとの最小値を管理する構造体
    set(int i, T x), build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n)
    update(i,x): i 番目の要素を x に更新。O(log(n))
    query(a,b): [a,b) での最小の要素を取得。O(log(n))
    find_rightest(a,b,x): [a,b) で x以下の要素を持つ最右位置を求める。O(log(n))
    find_leftest(a,b,x): [a,b) で x以下の要素を持つ最左位置を求める。O(log(n))
  */
  template <typename T>
  struct RMQ {
      const T e = numeric_limits<T>::max();
      function<T(T, T)> fx = [](T x1, T x2) -> T { return min(x1, x2); };
      int n;
      vector<T> dat;
      RMQ(int n_) : n(), dat(n_ * 4, e) {
          int x = 1;
          while (n_ > x) {
              x *= 2;
          }
          n = x;
      }

      void set(int i, T x) { dat[i + n - 1] = x; }
      void build() {
          for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);
      }

      void update(int i, T x) {
          i += n - 1;
          dat[i] = x;
          while (i > 0) {
              i = (i - 1) / 2;  // parent
              dat[i] = fx(dat[i * 2 + 1], dat[i * 2 + 2]);
          }
      }

      // the minimum element of [a,b)
      T query(int a, int b) { return query_sub(a, b, 0, 0, n); }
      T query_sub(int a, int b, int k, int l, int r) {
          if (r <= a || b <= l) {
              return e;
          } else if (a <= l && r <= b) {
              return dat[k];
          } else {
              T vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
              T vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
              return fx(vl, vr);
          }
      }

      int find_rightest(int a, int b, T x) { return find_rightest_sub(a, b, x, 0, 0, n); }
      int find_leftest(int a, int b, T x) { return find_leftest_sub(a, b, x, 0, 0, n); }
      int find_rightest_sub(int a, int b, T x, int k, int l, int r) {
          if (dat[k] > x || r <= a || b <= l) {  // 自分の値がxより大きい or [a,b)が[l,r)の範囲外ならreturn a-1
              return a - 1;
          } else if (k >= n - 1) {  // 自分が葉ならその位置をreturn
              return (k - (n - 1));
          } else {
              int vr = find_rightest_sub(a, b, x, 2 * k + 2, (l + r) / 2, r);
              if (vr != a - 1) {  // 右の部分木を見て a-1 以外ならreturn
                  return vr;
              } else {  // 左の部分木を見て値をreturn
                  return find_rightest_sub(a, b, x, 2 * k + 1, l, (l + r) / 2);
              }
          }
      }
      int find_leftest_sub(int a, int b, T x, int k, int l, int r) {
          if (dat[k] > x || r <= a || b <= l) {  // 自分の値がxより大きい or [a,b)が[l,r)の範囲外ならreturn b
              return b;
          } else if (k >= n - 1) {  // 自分が葉ならその位置をreturn
              return (k - (n - 1));
          } else {
              int vl = find_leftest_sub(a, b, x, 2 * k + 1, l, (l + r) / 2);
              if (vl != b) {  // 左の部分木を見て b 以外ならreturn
                  return vl;
              } else {  // 右の部分木を見て値をreturn
                  return find_leftest_sub(a, b, x, 2 * k + 2, (l + r) / 2, r);
              }
          }
      }
  };
}

algo_logic_segtree4{
  /* SegTree<X>(n,fx,ex): モノイド(集合X, 二項演算fx, 単位元ex)についてサイズnで構築
    set(int i, X x), build(): i番目の要素をxにセット。まとめてセグ木を構築する。O(n)
    update(i,x): i 番目の要素を x に更新。O(log(n))
    query(a,b): [a,b) 全てにfxを作用させた値を取得。O(log(n))
  */
  template <typename X>
  struct SegTree {
      using FX = function<X(X, X)>; // X•X -> X となる関数の型
      int n;
      FX fx;
      const X ex;
      vector<X> dat;
      SegTree(int n_, FX fx_, X ex_) : n(), fx(fx_), ex(ex_), dat(n_ * 4, ex_) {
          int x = 1;
          while (n_ > x) {
              x *= 2;
          }
          n = x;
      }

      void set(int i, X x) { dat[i + n - 1] = x; }
      void build() {
          for (int k = n - 2; k >= 0; k--) dat[k] = fx(dat[2 * k + 1], dat[2 * k + 2]);
      }

      void update(int i, X x) {
          i += n - 1;
          dat[i] = x;
          while (i > 0) {
              i = (i - 1) / 2;  // parent
              dat[i] = fx(dat[i * 2 + 1], dat[i * 2 + 2]);
          }
      }

      X query(int a, int b) { return query_sub(a, b, 0, 0, n); }
      X query_sub(int a, int b, int k, int l, int r) {
          if (r <= a || b <= l) {
              return ex;
          } else if (a <= l && r <= b) {
              return dat[k];
          } else {
              X vl = query_sub(a, b, k * 2 + 1, l, (l + r) / 2);
              X vr = query_sub(a, b, k * 2 + 2, (l + r) / 2, r);
              return fx(vl, vr);
          }
      }
  };
}

abc257c{
  #include <bits/stdc++.h>
  using namespace std;

  int main() {
    int n, x, ans;
    string s;
    vector<pair<int, char> >a;
    cin >> n;
    cin >> s;
    ans = 0;
    for (int i = 0; i < n; i++) {
      cin >> x;
      a.push_back({ x,s[i] });
      if (s[i] == '1')ans++;
    }
    sort(a.begin(), a.end());
    x = ans;
    for (int i = 0; i < n; i++) {
      if (a[i].second == '1')x--;
      else x++;
      if (i < (n - 1)) {
        if (a[i].first != a[i + 1].first)ans = max(ans, x);
      }
      else ans = max(ans, x);
    }
    cout << ans << endl;
    return 0;
  }

}

abc257d{
  #include<bits/stdc++.h>
  using namespace std;

  int main(){
    int N;
    cin >> N;
    vector<vector<long long>>data(N);
    for(int i=0;i<N;i++){
      int x,y,p;
      cin >> x >> y >> p;
      data[i]={x,y,p};
    }
    
    vector<vector<long long>>dist(N,vector<long long>(N));
    for(int i=0;i<N;i++)for(int j=0;j<N;j++){
      dist[i][j]=(abs(data[i][0]-data[j][0])+abs(data[i][1]-data[j][1])+data[i][2]-1)/data[i][2];
    }

    for(int k=0;k<N;k++)for(int i=0;i<N;i++)for(int j=0;j<N;j++)dist[i][j]=min(dist[i][j],max(dist[i][k],dist[k][j]));

    long long ans=1e15;
    for(int i=0;i<N;i++){
      long long tans=0;
      for(int j=0;j<N;j++)tans=max(tans,dist[i][j]);
      ans=min(ans,tans);
    }
    cout << ans << endl;
  }

}

abc257e{
  #include <bits/stdc++.h>
  using namespace std;

  using ll = long long;

  int main() {
      int n;
      cin >> n;
      vector<int> c(10);
      for(int i = 1; i <= 9; i++) cin >> c[i];

      int mn = *min_element(c.begin() + 1, c.end());
      int length = n / mn;

      string ans = "";

      for(int i = 0; i < length; i++) {
          for(int j = 9; j >= 1; j--) {
              if((ll)mn * (length - 1 - i) + c[j] <= n) {
                  n -= c[j];
                  ans.push_back((char)('0' + j));
                  break;
              }
          }
      }

      cout << ans << endl;

      return 0;
  }

}

abc257f{
  #include <bits/stdc++.h>
  using namespace std;

  #define rep(i, n) for(int i = 0; i < n; ++i)
  #define N 300010
  #define INF (int)1e+9

  int main(void) {
    int n, m;
    bool ex[N];
    bool used[N];
    rep(i, N)ex[i] = false;
    vector<int>e[N];
    int d[2][N];
    queue<int>q;
    int mn[2];
    int x, y;

    cin >> n >> m;
    for (int i = 0; i < m; i++) {
      cin >> x >> y;
      if (x == 0)ex[y - 1] = true;
      else {
        e[x - 1].push_back(y - 1);
        e[y - 1].push_back(x - 1);
      }
    }

    for (int i = 0; i < n; i++)d[0][i] = INF;
    for (int i = 0; i < n; i++)used[i] = false;
    mn[0] = INF;
    used[0] = true;
    d[0][0] = 0;
    q.push(0);
    while (!q.empty()) {
      x = q.front();
      q.pop();
      if (ex[x])mn[0] = min(mn[0], d[0][x]);
      y = e[x].size();
      for (int i = 0; i < y; i++) {
        if (!used[e[x][i]]) {
          used[e[x][i]] = true;
          d[0][e[x][i]] = d[0][x] + 1;
          q.push(e[x][i]);
        }
      }
    }

    for (int i = 0; i < n; i++)d[1][i] = INF;
    for (int i = 0; i < n; i++)used[i] = false;
    mn[1] = INF;
    used[n - 1] = true;
    d[1][n - 1] = 0;
    q.push(n - 1);
    while (!q.empty()) {
      x = q.front();
      q.pop();
      if (ex[x])mn[1] = min(mn[1], d[1][x]);
      y = e[x].size();
      for (int i = 0; i < y; i++) {
        if (!used[e[x][i]]) {
          used[e[x][i]] = true;
          d[1][e[x][i]] = d[1][x] + 1;
          q.push(e[x][i]);
        }
      }
    }

    for (int i = 0; i < n; i++) {
      x = min(d[0][n - 1], mn[0] + mn[1] + 2);
      x = min(x, mn[0] + 1 + d[1][i]);
      x = min(x, mn[1] + 1 + d[0][i]);
      if (x < INF)cout << x;
      else cout << -1;
      if (i < (n - 1))cout << " ";
      else cout << endl;
    }

    return 0;
  }

}

abc252g1{
  #include <bits/stdc++.h>
  using namespace std;

  #define MOD 998244353

  int main() {
    int n;
    int a[501];
    long long dp[501][501][2];

    cin >> n;
    for (int i = 0; i < n; i++)cin >> a[i];
    a[n + 1] = n + 1;

    for (int r = 0; r < n; r++) {
      for (int i = 0; i < 2; i++)dp[r][r][i] = 1LL;
      for (int l = r - 1; l >= 0; l--) {
        for (int i = 0; i < 2; i++)dp[l][r][i] = 0LL;
        for (int k = l; k < r; k++) {
          dp[l][r][0] = (dp[l][r][0] + (dp[l][k][1] * dp[k + 1][r][0])) % MOD;
          if (a[k + 1] < a[r + 1])dp[l][r][1] = (dp[l][r][1] + (dp[l][k][1] * dp[k + 1][r][0])) % MOD;
        }
      }
    }

    cout << dp[0][n - 1][0] << endl;
    return 0;
  }

}
abc252g2{
  #include <bits/stdc++.h>
  using namespace std;

  #define MOD 998244353

  int main() {
    int n;
    int a[500];
    long long dp[501][501];

    cin >> n;
    for (int i = 0; i < n; i++)cin >> a[i];

    for (int l = n; l >= 1; l--) {
      dp[l][l] = 1;
      for (int r = l + 1; r <= n; r++) {
        dp[l][r] = dp[l + 1][r];
        for (int k = l + 1; k < r; k++) {
          if (a[l] < a[k])dp[l][r] = (dp[l][r] + (dp[l + 1][k] * dp[k][r])) % MOD;
        }
      }
    }

    cout << dp[1][n] << endl;
    return 0;
  }

}

arc143{
  #include <iostream>
  #include <algorithm>
  #include <bitset>
  #include <cmath>
  #include <functional>
  #include <iomanip>
  #include <map>
  #include <numeric>
  #include <queue>
  #include <random>
  #include <regex>
  #include <set>
  #include <sstream>
  #include <stack>
  #include <string>
  #include <unordered_set>
  #include <vector>
  using namespace std;

  #include <atcoder/all>
  using namespace atcoder;
  //using mint = modint;
  //using mint = modint1000000007;
  using mint = modint998244353;

  struct comb {
    vector<mint> F, IF;
    comb(int size) {
      F.resize(size);
      IF.resize(size);
      F[0] = 1, IF[0] = 1;
      for (int i = 1; i < size; i++) {
        F[i] = F[i - 1] * i;
        IF[i] = F[i].inv();
      }
    }
    mint c(int a, int b) {
      if (a < b || b < 0) return 0;
      return F[a] * IF[b] * IF[a - b];
    }
  };
  int main() {
    int N;
    cin >> N;
    comb c(N * N + 1);
    mint ans = c.F[N * N] - N * N * c.c(N * N, N + N - 1) * c.F[N - 1] * c.F[N - 1] * c.F[N * N - N - N + 1];
    cout << ans.val() << endl;

  }
}